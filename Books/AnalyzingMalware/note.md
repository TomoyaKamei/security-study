# アナライジングマルウェア



## 第1章ファイルをダウンロードするマルウェアの解析


## 第2章 パックされているマルウェアの解析

### 2.1 はじめに
- パッカーは、プログラムの実行形式を保ったまま圧縮・難読化するツールの事である。
- パッカーは、本来のコード部分を実行する前に、圧縮・難読化されたコードを展開するための処理が実行される。

### 2.2 PEファイルフォーマット
- **2.2.0 概要**
    - PEファイルフォーマットは、ローダがプログラムをロードするのに必要な情報が格納されたヘッダとプログラムコードやリソースデータなどが記録されているセクションで構成されている。
    - ヘッダ
        - DOS MZヘッダ
        - DOSスタブ
        - PEヘッダ
        - セクションテーブル
    - セクション
    - RVA(Relative Virtual Address; 相対仮想アドレス)
        - プログラムがメモリロードされたアドレスからの相対アドレス

- **2.2.1 DOS MZヘッダ/DOSスタブ**
    - DOS MZヘッダは。IMAGE_DOS_HEADERとして定義されている。
    - DOS MZヘッダのサイズは64バイトで、19個のメンバから構成されている。
    ```
    typedef struct _IMAGE_DOS_HEADER {
        WORD    e_magic;    // Windows実行ファイルの場合は0x4D, 0x5A(MZ)となる。
        WORD    e_cblp;
        WORD    e_cp;
        WORD    e_crlc;
        WORD    e_cparhdr;
        WORD    e_minalloc;
        WORD    e_maxalloc;
        WORD    e_ss;
        WORD    e_sp;
        WORD    e_csum;
        WORD    e_ip;
        WORD    e_cs;
        WORD    e_lfarlc;
        WORD    e_ovno;
        WORD    e_res[4];
        WORD    e_oemid;
        WORD    e_oeinfo;
        WORD    e_res2[10];
        WORD    e_lfanew;  // PEヘッダへのオフセット値(PEヘッダが開始されるアドレス)
    } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
    ```
    - DOSスタブは、DOS MZヘッダの次の領域で、通常は"This program cannot be run in DOS mode"と表示されるように文字列などが配置されている。

- **2.2.2 PEヘッダ**
    - PEヘッダは、IMAGE_NT_HEADERSとして定義されており、Signature・FileHeader・OptionalHeaderの3つのメンバから構成されている。
    ```
    typedef struct _IMAGE_NT_HEADERS{
        DWORD Signature;                        // PEヘッダの先頭4バイトでPE(0x50, 0x45, 0x00, 0x00)が入る。 
        IMAGE_FILE_HEADER FileHeader;           // ファイルヘッダ
        IMAGE_OPTIONAL_HEADER32 OptionalHeader; // オプショナルヘッダ
    } IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;

    typedef struct _IMAGE_FILE_HEADER{
        WORD    Machine;
        WORD    NumberOfSections;               // セクションの数を示す値
        DWORD   TimeDateStamp;                  
        DWORD   PointerToSymbolTable;
        DWORD   NumberOfSymbols;
        WORD    SizeOfOptionalHeader;           // OptionalHeaderのサイズ
        WORD    Characteristics;                // ファイルの属性を表すフラグ値の論理和
    } IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

    typedef struct _IMAGE_OPTIONAL_HEADER {
        WORD    Magic;
        BYTE    MajorLinkerVersion;
        BYTE    MinorLinkerVersion;
        DWORD   SizeOfCode;
        DWORD   SizeOfInitializedData;
        DWORD   SizeOfUninitalizedData;
        DWORD   AddressOfEntryPoint;            // プログラムの実行開始アドレス(RVA)
        DWORD   BaseOfCode;
        DWORD   BaseOfData;
        DWORD   ImageBase;                      // プログラムがメモリ上にロードされる時の理想的な開始アドレス(実行ファイル: 0x00400000, DLL: 0x10000000)
        DWORD   SectionAlignment;               // メモリ上にロードされる時に各セクションが配置されるアラインメント(各セクションの開始アドレスがSectionAlignmentの倍数になる。)
        DWORD   FileAlignment;                  // ディスク上で各セクションが配置されるアラインメント(各セクションの開始アドレスがFileAlignmentの倍数になる。)
        WORD    MajorOperatingSysmtemVersion;
        WORD    MinorOperatingSysmtemVersion;
        WORD    MajorImageVersion;
        WORD    MinorImageVersion;
        WORD    MajorSubsystemVersion;
        WORD    MajorSubsystemVersion;
        DWORD   Win32VersionValue;
        DWORD   SizeOfImage;                    // メモリ上にロードされたプログラムのサイズ
        DWORD   SizeOfHeaders;
        DWORD   CheckSum;
        WORD    Subsystem;
        WORD    DllCharacteristics;
        DWORD   SizeOfStackReserve;
        DWORD   SizeOfStackCommit;
        DWORD   SizeOfHeapReserve;
        DWORD   SizeOfHeapCommit;
        DWORD   LoaderFlags;
        DWORD   NumberOfRvaAndSizes;            // IMAGE_DATA_DIRECTORY構造体の配列。インポートしている関数やエクスポートしている関数の情報などを参照するためのテーブルの位置とサイズ構成されている
        IMAGE_DATA_DIRECTORY DataDirectory[16];
    }

    typedef struct _IMAGE_DATA_DIRECTORY {
        DWORD   VirtualAddress;
        DWORD   Size;
    }
    ```

- **2.2.3 セクションテーブル**
    - セクションテーブルは、IMAGE_SECTION_HEADERとして定義されており、セクションのサイズや開始アドレス、属性などを指定している。
    ```
    typedef struct _IMAGE_SECTION_HEADER {
        BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];  // セクションに付けられる名前
        union   {
            DWORD   PhysicalAddress;
            DWORD   VirtualSize;                // プログラムがメモリ上にロードされた時のセクションのサイズ
        } Misc;
        DWORD   VirtualAddress;                 // プログラムがメモリ表にロードされた時のセクション先頭アドレスのRVA
        DWORD   SizeOfRawData;                  // ディスク上に置けるセクションのサイズ
        DWORD   PointerToRawData;               // ディスク上に置けるセクションの先頭へのオフセット
        DWORD   PointerToRelocations;
        DWORD   PointerToLinenumbers;
        WORD    NumberOfRelocations;
        WORD    NumberOfLinenumbers;
        DWORD   Characteristics;                // セクションの属性を表すフラグ値の論理値
    } IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;
    ```

- **2.2.4 セクション**
    - セクションには、役割に応じていくつかの種類が存在する。
        - コードセクション
        - データセクション
        - リソースセクション
        - エクスポートセクション
        - インポートセクション
        - TLS(Thread Local Storage)セクション
    - **インポートセクション**
        - インポートセクションにおいては、外部DLLからインポートする関数の情報が含まれている。
        - インポートテーブルは、IMAGE_IMPORT_DESCRIPTOR構造体の配列として定義されている。
        - インポートテーブルの終端は、全てのフィールドが0で埋められたIMAGE_IMPORT_DESCRIPTORで表現される。
            ```
            typedef struct _IMAGE_IMPORT_DESCRIPTOR {
                union {
                    DWORD Characteristics;      
                    DWORD OriginalFirstThunk;   // Import LookUp Table(ILA)のRelative Virtual Address(RVA)、ILAはIMAGE_THUNK_DATA構造体の配列である。
                }

                DWORD   TimeDateStamp;
                DWORD   ForwarderChain;
                DWORD   Name;                   // ImportしているDLL名のRVA
                DWORD   FirstThunk;             // Import Address Table(IAT)のRelative Virtual Address(RVA)、プログラムロード前まではILTと同じである。
            } IMAGE_IMPORT_DESCRIPTOR;
            
            typedef struct _IMAGE_THUNK_DATA32 {
                union {
                    DWORD ForwarderString;
                    DWORD Function;
                    DWORD Ordinal;
                    DWORD AddressOfData;        // IMAGE_IMPORT_BY_NAME構造体へのポインタ
                } u1;
            } IMAGE_THUNK_DATA32


            typedef struct _IMAGE_IMPORT_BY_NAME{
                WORD Hint;      // インポートする関数のヒント
                BYTE Name[1];   ・・
            } IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;
            ```

- **2.2.5 PEhファイルフォーマットを確認するツール**
    - LordPEやdumpbinがツールとしては存在する。

### 2.3 パック
- **2.3.1 パックされたプログラムの特徴**
    1. インポートされているAPIの数が少ない。
    2. 意味のある文字列が見当たらない。
    3. セクション名が変更される。

- **2.3.2 パックされたプログラムの実行フロー**
    - パックされたプログラムは、復号化用のプログラムがエントリポイント付近に追加されている。
    - 基本的な戦略は以下の通りである。
        1. 実行ファイルの展開ルーチンが実行される。
        2. パックされたコードがメモリに展開される。
        3. 展開されたコードのIATを再構築する。
            - 展開されたコードがインポートしている関数を呼び出せるようにローダが本来行うIATの書き換え処理を展開ルーチンの中で実行する必要がある。
        4. 展開されたコードを実行する。
- **2.3.3 自作パッカーで動作を理解する**

### 2.4 アンパック
- **2.4.1 アンパックに使うツール**
- **2.4.2 マニュアルアンパック**
- **2.4.3 アンパックの実例**

### 2.5 アンパックを妨害するテクニック
- **2.5.1 Stoken Bytes**
- **2.5.2 SizeOfImageの改変**
- **2.5.3 Import Redirection**

### 2.6 まとめ