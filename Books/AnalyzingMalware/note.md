# アナライジングマルウェア



## 第1章ファイルをダウンロードするマルウェアの解析


## 第2章 パックされているマルウェアの解析

### 2.1 はじめに
- パッカーは、プログラムの実行形式を保ったまま圧縮・難読化するツールの事である。
- パッカーは、本来のコード部分を実行する前に、圧縮・難読化されたコードを展開するための処理が実行される。

### 2.2 PEファイルフォーマット
- **2.2.0 概要**
    - PEファイルフォーマットは、ローダがプログラムをロードするのに必要な情報が格納されたヘッダとプログラムコードやリソースデータなどが記録されているセクションで構成されている。
    - ヘッダ
        - DOS MZヘッダ
        - DOSスタブ
        - PEヘッダ
        - セクションテーブル
    - セクション
    - RVA(Relative Virtual Address; 相対仮想アドレス)
        - プログラムがメモリロードされたアドレスからの相対アドレス

- **2.2.1 DOS MZヘッダ/DOSスタブ**
    - DOS MZヘッダは。IMAGE_DOS_HEADERとして定義されている。
    - DOS MZヘッダのサイズは64バイトで、19個のメンバから構成されている。
    ```
    typedef struct _IMAGE_DOS_HEADER {
        WORD    e_magic;    // Windows実行ファイルの場合は0x4D, 0x5A(MZ)となる。
        WORD    e_cblp;
        WORD    e_cp;
        WORD    e_crlc;
        WORD    e_cparhdr;
        WORD    e_minalloc;
        WORD    e_maxalloc;
        WORD    e_ss;
        WORD    e_sp;
        WORD    e_csum;
        WORD    e_ip;
        WORD    e_cs;
        WORD    e_lfarlc;
        WORD    e_ovno;
        WORD    e_res[4];
        WORD    e_oemid;
        WORD    e_oeinfo;
        WORD    e_res2[10];
        WORD    e_lfanew;  // PEヘッダへのオフセット値(PEヘッダが開始されるアドレス)
    } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
    ```
    - DOSスタブは、DOS MZヘッダの次の領域で、通常は"This program cannot be run in DOS mode"と表示されるように文字列などが配置されている。

- **2.2.2 PEヘッダ**
    - PEヘッダは、IMAGE_NT_HEADERSとして定義されており、Signature・FileHeader・OptionalHeaderの3つのメンバから構成されている。
    ```
    typedef struct _IMAGE_NT_HEADERS{
        DWORD Signature;                        // PEヘッダの先頭4バイトでPE(0x50, 0x45, 0x00, 0x00)が入る。 
        IMAGE_FILE_HEADER FileHeader;           // ファイルヘッダ
        IMAGE_OPTIONAL_HEADER32 OptionalHeader; // オプショナルヘッダ
    } IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;

    typedef struct _IMAGE_FILE_HEADER{
        WORD    Machine;
        WORD    NumberOfSections;               // セクションの数を示す値
        DWORD   TimeDateStamp;                  
        DWORD   PointerToSymbolTable;
        DWORD   NumberOfSymbols;
        WORD    SizeOfOptionalHeader;           // OptionalHeaderのサイズ
        WORD    Characteristics;                // ファイルの属性を表すフラグ値の論理和
    } IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

    typedef struct _IMAGE_OPTIONAL_HEADER {
        WORD    Magic;
        BYTE    MajorLinkerVersion;
        BYTE    MinorLinkerVersion;
        DWORD   SizeOfCode;
        DWORD   SizeOfInitializedData;
        DWORD   SizeOfUninitalizedData;
        DWORD   AddressOfEntryPoint;            // プログラムの実行開始アドレス(RVA)
        DWORD   BaseOfCode;
        DWORD   BaseOfData;
        DWORD   ImageBase;                      // プログラムがメモリ上にロードされる時の理想的な開始アドレス(実行ファイル: 0x00400000, DLL: 0x10000000)
        DWORD   SectionAlignment;               // メモリ上にロードされる時に各セクションが配置されるアラインメント(各セクションの開始アドレスがSectionAlignmentの倍数になる。)
        DWORD   FileAlignment;                  // ディスク上で各セクションが配置されるアラインメント(各セクションの開始アドレスがFileAlignmentの倍数になる。)
        WORD    MajorOperatingSysmtemVersion;
        WORD    MinorOperatingSysmtemVersion;
        WORD    MajorImageVersion;
        WORD    MinorImageVersion;
        WORD    MajorSubsystemVersion;
        WORD    MajorSubsystemVersion;
        DWORD   Win32VersionValue;
        DWORD   SizeOfImage;                    // メモリ上にロードされたプログラムのサイズ
        DWORD   SizeOfHeaders;
        DWORD   CheckSum;
        WORD    Subsystem;
        WORD    DllCharacteristics;
        DWORD   SizeOfStackReserve;
        DWORD   SizeOfStackCommit;
        DWORD   SizeOfHeapReserve;
        DWORD   SizeOfHeapCommit;
        DWORD   LoaderFlags;
        DWORD   NumberOfRvaAndSizes;            // IMAGE_DATA_DIRECTORY構造体の配列。インポートしている関数やエクスポートしている関数の情報などを参照するためのテーブルの位置とサイズ構成されている
        IMAGE_DATA_DIRECTORY DataDirectory[16];
    }

    typedef struct _IMAGE_DATA_DIRECTORY {
        DWORD   VirtualAddress;
        DWORD   Size;
    }
    ```

- **2.2.3 セクションテーブル**
    - セクションテーブルは、IMAGE_SECTION_HEADERとして定義されており、セクションのサイズや開始アドレス、属性などを指定している。
    ```
    typedef struct _IMAGE_SECTION_HEADER {
        BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];  // セクションに付けられる名前
        union   {
            DWORD   PhysicalAddress;
            DWORD   VirtualSize;                // プログラムがメモリ上にロードされた時のセクションのサイズ
        } Misc;
        DWORD   VirtualAddress;                 // プログラムがメモリ表にロードされた時のセクション先頭アドレスのRVA
        DWORD   SizeOfRawData;                  // ディスク上に置けるセクションのサイズ
        DWORD   PointerToRawData;               // ディスク上に置けるセクションの先頭へのオフセット
        DWORD   PointerToRelocations;
        DWORD   PointerToLinenumbers;
        WORD    NumberOfRelocations;
        WORD    NumberOfLinenumbers;
        DWORD   Characteristics;                // セクションの属性を表すフラグ値の論理値
    } IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;
    ```

- **2.2.4 セクション**
    - セクションには、役割に応じていくつかの種類が存在する。
        - コードセクション
        - データセクション
        - リソースセクション
        - エクスポートセクション
        - インポートセクション
        - TLS(Thread Local Storage)セクション
    - **インポートセクション**
        - インポートセクションにおいては、外部DLLからインポートする関数の情報が含まれている。
        - インポートテーブルは、IMAGE_IMPORT_DESCRIPTOR構造体の配列として定義されている。
        - インポートテーブルの終端は、全てのフィールドが0で埋められたIMAGE_IMPORT_DESCRIPTORで表現される。
            ```
            typedef struct _IMAGE_IMPORT_DESCRIPTOR {
                union {
                    DWORD Characteristics;      
                    DWORD OriginalFirstThunk;   // Import LookUp Table(ILA)のRelative Virtual Address(RVA)、ILAはIMAGE_THUNK_DATA構造体の配列である。
                }

                DWORD   TimeDateStamp;
                DWORD   ForwarderChain;
                DWORD   Name;                   // ImportしているDLL名のRVA
                DWORD   FirstThunk;             // Import Address Table(IAT)のRelative Virtual Address(RVA)、プログラムロード前まではILTと同じである。
            } IMAGE_IMPORT_DESCRIPTOR;
            
            typedef struct _IMAGE_THUNK_DATA32 {
                union {
                    DWORD ForwarderString;
                    DWORD Function;
                    DWORD Ordinal;
                    DWORD AddressOfData;        // IMAGE_IMPORT_BY_NAME構造体へのポインタ
                } u1;
            } IMAGE_THUNK_DATA32


            typedef struct _IMAGE_IMPORT_BY_NAME{
                WORD Hint;      // インポートする関数のヒント
                BYTE Name[1];   ・・
            } IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;
            ```

- **2.2.5 PEhファイルフォーマットを確認するツール**
    - LordPEやdumpbinがツールとしては存在する。

### 2.3 パック
- **2.3.1 パックされたプログラムの特徴**
    1. インポートされているAPIの数が少ない。
    2. 意味のある文字列が見当たらない。
    3. セクション名が変更される。

- **2.3.2 パックされたプログラムの実行フロー**
    - パックされたプログラムは、復号化用のプログラムがエントリポイント付近に追加されている。
    - 基本的な戦略は以下の通りである。
        1. 実行ファイルの展開ルーチンが実行される。
        2. パックされたコードがメモリに展開される。
        3. 展開されたコードのIATを再構築する。
            - 展開されたコードがインポートしている関数を呼び出せるようにローダが本来行うIATの書き換え処理を展開ルーチンの中で実行する必要がある。
        4. 展開されたコードを実行する。
- **2.3.3 自作パッカーで動作を理解する**
    - 本パッカーは、コード領域をXORでエンコードするのみである。
    ```c
    #include <stdio.h>
    #include <windows.h>

    // デコードするためのコード
    unsigned char decode_stub[] = {
        0x60,                               // pushad;                  展開ルーチンの始動
        0xBE,0xFF,0xFF,0xFF,0xFF,           // mov esi, decode_start;   展開ルーチンのアドレスをesiに格納 
        0xB9,0xFF,0xFF,0xFF,0xFF,           // mov ecx, decode_size;    展開後のコードサイズをecxに格納
        0x81,0xC6,0xFF,0xFF,0xFF,0xFF,      // add esi, base_addr;      展開ルーチンのアドレスに基底アドレスを追加
        0xB0,0xFF,                          // mov al, decoder;         alにxorの対象となるコードを格納
        0x30,0x06,                          // xor byte ptr [esi], al;  xor [esi] decoder
        0x46,                               // inc esi;                 esiを追加
        0x49,                               // dec ecx;                 esxを減算
        0x75,0xFA,                          // jnz LOOP;                LOOPが0になるまでループ
        0x61,                               // popad;                   ポップ
        0xE9,0xFF,0xFF,0xFF,0xFF,           // jmp OEP, オリジナルエンドポイントへ移動 
    };

    unsigned int decode_start_offset        = 2;
    unsigned int decode_size_offset         = 7;
    unsigned int base_address_offset        = 13;
    unsigned int decoder_offset             = 18;
    unsigned int jmp_oep_addr_offset        = 27;

    void create_decode_stub (
        unsigned int code_vaddr,
        unsigned int code_vsize,
        unsigned int base_addr,
        BYTE decoder,
        unsigned int oep
    )
    {
        int cnt = 0;
        int jmp_len_to_oep = 0; // オリジナルエンドポイントまでのオフセット

        jmp_len_to_oep = oep - (code_vaddr + code_vsize + sizeof(decode_stub));
        
    }
    
    ```

### 2.4 アンパック
- **2.4.1 アンパックに使うツール**
- **2.4.2 マニュアルアンパック**
- **2.4.3 アンパックの実例**

### 2.5 アンパックを妨害するテクニック
- **2.5.1 Stoken Bytes**
- **2.5.2 SizeOfImageの改変**
- **2.5.3 Import Redirection**

### 2.6 まとめ

## 第3章 動的解析を妨害するマルウェアの解析

### 3.1 はじめに

### 3.2 動的解析ツールの検出

### 3.3 タイマーによるチェック

### 3.4 マルウェア自身の再起動

### 3.5 デバッガの検出

### 3.6 仮想化ソフトウェア上での動作の検出

### 3.7 様々な例外発生への対処

### 3.8 APIに設定されたブレークポイントの検出
