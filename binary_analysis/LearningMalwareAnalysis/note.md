## 第一章　ようこそ、マルウェア解析の世界へ

## 第二章　表層解析

### 2.0 概要

- **表層解析**とは、分析対象ファイルを実行せずに分析する手法の事である。
- 分析できる内容としては、以下の通りである。
  - マルウェアが標的としているアーキテクチャの特定
  - マルウェアのフィンガープリント
  - マルウェア対策エンジンを使用した分析対象ファイルのスキャン
  - ファイルに関連付けられている文字列・関数・メタデータの抽出
  - 分析を妨害するために利用された難読化手法の特定
  - マルウェアの分類と比較

### 2.1 ファイル形式の判別

- 分析対象ファイル形式を調べる事でマルウェアが標的としているOSがわかる。

  - **PE(Portable Executable)ファイルフォーマット**であれば、WIndowsの実行ファイル形式であるのでWindowsを対象としているなど...

- ファイル形式にのみ着目するのはよくない。理由としては偽装が容易だからである。

- そこで、**ファイルシグニチャ**と呼ばれるファイルのヘッダにある一意性を持つバイト列を利用して判別するのが良い。

  - PEファイルは、ファイルの最初の2バイトにMZもしくは、16進数文字列**4D 5A**というシグニチャがついている。
  - ELFファイルは、ファイルの最初の4バイトが16進数文字列**7F 45 4C 46**である。

  ```
  root@DESKTOP-449AIPT:~/go/bin# xxd -g 1 protoc-gen-go | more
  00000000: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00  .ELF............
  00000010: 02 00 3e 00 01 00 00 00 e0 8b 45 00 00 00 00 00  ..>.......E.....
  00000020: 40 00 00 00 00 00 00 00 c8 01 00 00 00 00 00 00  @...............
  ```

- また、**file**コマンドを使用してファイルの形式を判断する事が出来る。

  ```
  root@DESKTOP-449AIPT:~/go/bin# file protoc-gen-go
  protoc-gen-go: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, Go BuildID=e83KzE8KlNGRo5PQ8af8/pTOuPTAPb4FUFqh_vBmH/bXGWpm06EvKkLqZUkvql/UwmH8mhc5ane3ctdQiN_, not stripped
  root@DESKTOP-449AIPT:~/go/bin#
  ```

- 最後はPythonでファイル形式を判別する方法である。

  ```
  (venv) root@DESKTOP-449AIPT:~/security# python3
  Python 3.8.10 (default, Sep 28 2021, 16:10:42)
  [GCC 9.3.0] on linux
  Type "help", "copyright", "credits" or "license" for more information.
  >>>
  >>>
  >>> import magic
  >>> magic.from_file('./venv/bin/activate')
  'ASCII text'
  >>>
  >>>
  ```

### 2.2 マルウェアのフィンガープリント

- マルウェアのファイル名は可変だが、マルウェアのファイルをハッシュ化したものは不変であるため、分析によく使用される。

- また、マルウェアの動的解析中に、マルウェアが自身をコピーしたり、C2サーバからマルウェアをインストールしたりするので、それがコピーしたのかを判断する際にも、ハッシュ値が使用される。

  ```
  (venv) root@DESKTOP-449AIPT:~/security# md5sum venv/bin/activate
  95be81d321835b81c9bcb91780d9076d  venv/bin/activate
  (venv) root@DESKTOP-449AIPT:~/security# sha256sum venv/bin/activate
  7ed76fbc1a5acd419e9793ae7bb57c703e2ff1931967a16d315f080893e0b0b5  venv/bin/activate
  (venv) root@DESKTOP-449AIPT:~/security# sha1sum venv/bin/activate
  4a0c6a17003172948aaec438ee536292bfe7a07d  venv/bin/activate
  ```

- また、Pythonによるハッシュ化も可能である。

  ```
  >>> print(hashlib.md5(open("venv/bin/activate", "rb").read()).hexdigest())
  95be81d321835b81c9bcb91780d9076d
  >>> print(hashlib.sha256(open("venv/bin/activate", "rb").read()).hexdigest())
  7ed76fbc1a5acd419e9793ae7bb57c703e2ff1931967a16d315f080893e0b0b5
  >>> print(hashlib.sha1(open("venv/bin/activate", "rb").read()).hexdigest())
  4a0c6a17003172948aaec438ee536292bfe7a07d
  ```


### 2.3 複数のマルウェア対策スキャン

- シグニチャの検索によって、調査使用としているマルウェアの性質等がよくわかる事が多い。
- **VirusTotal**は、中でも人気のあるWebベースのマルウェアスキャンサービスである。
  - スキャン対象となるファイルのアップロードだけではなく、ハッシュ・URL・ドメイン・IPアドレスを使用してもデータベースを検索する事が可能である。
  - その他にも、**pestudio**や**PPEE**と呼ばれるPE分析ツールも存在する。
- ファイルのアップロードを実施する事で、マルウェアのシグニチャを特定する行為は以下の事に留意する必要がある。
  - プライベートな情報が含まれていないか事前に調べておくこと
  - マルウェアのシグネチャに登録されていなくても、マルウェアである可能性は否定できない事
  - 登録さえすれば、どのユーザもファイルのアップロードが可能であるため、悪意のある第三者によっても見られて対策をされている可能性がある事

### 2.4 文字列の抽出

- マルウェアに組み込まれたASCIIもしくはUnicode文字列によってマルウェア内の情報を得る手がかりとなる。

- Linuxにおいて、分析対象ファイルから文字列を抽出する場合はstringsコマンドを使用する。

  - デフォルトで4文字以上のASCII文字列を抽出する。
  - -a オプションにより、ファイル全体から文字列を抽出する事が可能である。
  - -elオプションにより、Unicode文字列からも抽出が可能である。

  ```
  root@DESKTOP-449AIPT:~# strings go/bin/protoc-gen-go | less
  e83KzE8KlNGRo5PQ8af8/pTOuPTAPb4FUFqh_vBmH/bXGWpm06EvKkLqZUkvql/UwmH8mhc5ane3ctdQiN_
  D$ H
  D$(H
  D$(H
  L$hH
  T$(H
  ;cpu.u
  D$PH
  T$(H
  L$xH
  T$(H9
  |$hL
  t$HL
  D$`H)
  D$PH
  D$'H
  T$@1
  ```

- また、普通のマルウェアでは単純にStringsコマンド等で文字列を抽出させないため、難読化手法を用いている。

- **FLOSS(FireEye Labs Obfuscated String Solver)**は、マルウェアから難読化された文字列を自動的に識別して抽出するように設計されたツールである。

### 2.5 ファイルの難読化の判別

- **パッカー**や**クリプター**と呼ばれるプログラムを使用し、難読化を行う。
- **パッカー**は、実行するマルウェアを入力とし、プログラムを圧縮する事で難読化する。実行する時は、解凍モジュールによって元のプログラムをメモリ内に展開する。
- **クリプター**も同様に実行するマルウェアを入力とし、プログラムを暗号化する。
- **パッカー**や**クリプター**を検出するために、**Exeinfo PE**というフリーウェアツールを使用する事が出来る。

### 2.6 PEヘッダ情報の分析

- PEファイルヘッダは、メモリ上のどの場所に実行ファイルを読み込む必要があるか、実行を開始するアドレス、アプリケーションが依存するライブラリ/関数のリストなどの情報が含まれる。
- 特に、OSのやり取りをインターフェースであるDLLを介してマルウェアの機能や目的、実行時に期待される挙動について示唆を得る事が出来る。
- PEファイルの中身は、セクション単位に分割されている。
  - .text  実行コードが含まれている
  - .data 読み書きされるデータとグローバル変数が含まれている。
  - .rdata 読み取り専用データ
  - .idata 存在している場合インポート情報を含む
  - edata 存在している場合、エクスポート情報を含む
  - .rsrc アイコン・ダイアログ・メニュー・文字列などのリソースを含む
- セクションを調べる事により、PEファイルの特徴などを知る事が出来る。
- PEヘッダには、プログラムがコンパイルされた時間を示すタイムスタンプが含まれている。

### 2.7 マルウェアの比較と分類

- **ファジーハッシュ**を用いてマルウェア間の類似率の決定に役立つ。
  - ssdeepなどが用いられる。
- **インポートハッシュ**は、同じ攻撃グループによって作成された関連する別のマルウェアを識別する手法である。
- より具体的に**インポートハッシュ**とは、ライブラリ/インポート関数の名前と実行ファイル内の特定の順序に基づいてハッシュ値を計算する手法である。
- **セクションハッシュ**は、PEファイルの各セクションのMD5を用いて比較する方法である。
- **YARA**は、マルウェア識別・分類のためのツールで特定のルールにあてはまるかどうかによってマルウェアを識別する事が可能である。

### 2.8 まとめ

- 表層解析は、マルウェア解析の第一歩であり、ファイルから有益な情報を引き出し、マルウェアの比較・分類を支援する事が出来る。



## 第三章 動的解析

### 3.0 概要

- **動的解析**とは、隔離された環境で検体を実行し、振る舞い・やり取り・システムへの影響などを監視する事により検体を分析する技術の事を指す。

### 3.1 解析環境の概要

- 動的解析中に監視する主な項目は以下の項目である。
  - **プロセス監視**
    - マルウェア実行中におけるプロセスの挙動を監視し、結果を分析する事
  - **ファイルシステム監視**
    - マルウェア実行中におけるファイルシステムの動作をリアルタイムで監視する事
  - **レジストリ監視**
    - アクセス/変更されたレジストリキー・マルウェアによって読み書きされるレジストリデータを監視する事
  - **ネットワーク監視**
    - マルウェア実行中に、システム間で送受信されるトラフィック情報をリアルタイムで監視する事

### 3.2 システムとネットワークの監視

### 3.3 動的解析ツール

### 3.4 動的解析の方法論

### 3.5 実践編

### 3.6 DLLの解析

### 3.7 まとめ



## 第四章 アセンブリ言語と逆アセンブル入門

### 4-0. 概要

- マルウェアの内部動作をより深く理解し、マルウェアの重要な側面を知るためには静的解析が必要である。

### 4-1. コンピュータの基礎

- 8bit = 1Byteで16進数で表すと、ちょうど16進数×2となる。この時の一つの16進数(4bit)をニブルという。
  - 例)  11110010 = F2
  - その他にも以下のような名称がある。
    - 16bit = ワード
    - 32bit = ダブルワード
    - 64bit = クワッドワード
- これらのバイトシーケンスは、デコードの仕方によってさまざまな意味を持つ。
- **メインメモリ**は、上位から下位に向けてマシンコードとデータを格納する。また、各バイトに一意の番号が割り当てられている。
  - **リトルエンディアン**は、データの格納方式で下位バイトは下位アドレスに格納される方式を示す。
    - バイトシーケンス: 00 01 36 CF
    - メモリ
      - 0x0000000000 CF
      - 0x0000000001 36
      - 0x0000000002 01
      - 0x0000000003 00
- **CPU**はマシンコードを実行する。マシンコードは命令とも呼ばれ、メモリに格納されている。
- **コンパイラ**は高級言語をマシンコードに翻訳するプログラムである。
  - 実際のコンパイルプロセスは以下の通りである。
    1. ソースコードの記述
    2. ソースコードをオブジェクトファイルまたはマシンコードに変換
    3. オブジェクトファイルは、リンカに渡された後、DLLと結合され実行ファイルとなる。
  - PEファイルの形式は以下の通りである。
    1. PEヘッダ
    2. .code(.text)
    3. .data(.data, .rdata, .rsrc)

### 4-2 CPUレジスタ

- メモリから読み込まれた値を格納する箇所である。
- **汎用レジスタ**
  - 全ての汎用レジスタは32bit(ダブルワード)である
    - **EAX** 32bit
      - **AX** 下位16bit
      - **AH** 上位8bit
      - **AL** 下位8bit
    - **EBX** 32bit
      - **BX** 下位16bit
      - **AH** 上位8bit
      - **BL** 下位8bit
    - **ECX** 32bit
      - **CX** 下位16bit
      - **CH** 上位8bit
      - **CL** 下位8bit
    - **EDX** 32bit
      - **DX** 下位16bit
      - **DH** 上位8bit
      - **DL** 下位8bit
    - **ESP** 32bit
      - **SP** 下位16bit
    - **EBP** 32bit
      - **BP** 下位16bit
    - **ESI** 32bit
      - **SI** 下位16bit
    - **EDI** 32bit
      - **DI** 下位16bit
- **命令ポインタ**
  - **EIP**は次に実行する命令のアドレスが含まれているレジスタである。
- **EFLAGSレジスタ**
  - **EFLAGSレジスタ**は、32bitのレジスタで各ビットはフラグとして機能する。

### 4-3 データ移動命令

- mov dst, srcでデータをある場所から別の場所へ移動させる命令である。
  - mov eax, 10  定数をeaxへ移動させる。
  - mov eax, ebx  ebxに格納された値をeaxへ移動させる。
  - mov eax, [0x403000] メモリの0x40300番地にある値をeaxへ移動させる。
  - mov eax, [ebx]  EBXレジスタに格納されたアドレスにある値をeaxへ移動させる。
  - mov [0x403000], eax  eaxの値を0x403000番地へ格納する。
  - mov [ebx], eax  eaxの値をebxに格納してあるアドレスへ格納する。
  - mov dword ptr [ebp-4], -1  -1()という値をebpに格納されたアドレスから-4した番地に格納する。 
  - mov eax, dword ptr [ebp-4]   ebpに格納されたアドレスから-4した番地に格納された値(-1)をeaxへ移動させる。
  - mov dword ptr [ebp-8], eax eaxに格納された値をebp-8した番地に格納する。
- lea dst, [アドレス] でアドレスをdstへ格納する。
  - lea ebx, [0x403000] メモリの0x403000番地をeaxへ移動させる。

### 4-4 算術演算

- add dst, srcはsrcとdstを足した後に結果をdstへ格納する。
  - add eax, 1  eax+1した後にeaxへ結果を格納する。
  - add eax, ebx  eax = eax+ebxと同じ
  - add [eax], 42  EBXに指定されているアドレスに格納された値に42を足す。
- sub dst, srcはsrcとdstを引いた後に結果をdstへ格納する。
- inc dstはdstの値に1を足す。
- dec dstはdstの値に1を引く。
- mul dstはdst*EAXレジスタの値され、EDXとEAXレジスタに格納される。
- div dstはEDXとEAXに被除数を入れ、dstに除数を入れる事で割り算を実施し、商はEAXへ、余りはEDXに格納される。
- 問題
  - mov dword ptr [ebp-4], 16h  [ebp-4:ebp]    = 16/00/00/00
  - mov dword ptr [ebp-8], 5      [ebp-8:ebp-4] = 05/00/00/00
  - mov eax, [ebp-4]                  eax = 00/00/00/16
  - add eax, [ebp-8]                   eax = 00/00/00/1B = 27
  - mov [ebp-0Ch], eax             [ebp-12:ebp-8] = 1B/00/00/00
  - mov  ecx, [ebp-4]                 ecx = 00/00/00/16
  - sub ecx, [ebp-8]                   ecx = 00/00/00/11
  - mov [ebp-10h], ecx              [ebp-16:ebp-12] = 11/00/00/00
- 回答
  - a = 22
  - b = 5 
  - c = a + b                  
  - d = a - b

### 4-5 ビット演算

- not xxxは、xxxのビットに対してnot演算を実施する。
- and  xxx yyyは、xxx = xxx & yyyと同じである。
- or xxx yyyは、xxx = xxx | yyyと同じである。
- nor xxx yyyは、xxx = !(xxx | yyy)と同じである。主にnor xxx xxxでxxxをクリアするのに使用される。
- shl dst countは、dstのビットをcountで指定されたビット数宇だけ左シフトする。
- shr dst countは、dstのビットをcountで指定されたビット数宇だけ右シフトする。
- rol  dst countは、dstのビットをcountで指定されたビット数宇だけ左回転する。(反対側に再出現させる。)
- ror  dst countは、dstのビットをcountで指定されたビット数宇だけ右回転する。(反対側に再出現させる。)

### 4-6 分岐と条件

- 分岐命令は、実行制御を別のメモリアドレスに移す。

- jmp <jump address>は、常にジャンプを行う。

- jz <jump address>は、cmp・testによる演算後、zf=1ならばジャンプする。

- jnz <jump address>は、cmp・testによる演算後、zf=0ならばジャンプする。

- jl <jump address>は、cmp・testによる演算後、sf=1ならばジャンプする。

- jle <jump address>は、cmp・testによる演算後、zf=1 or sf=1ならばジャンプする。

- jg <jump address>は、cmp・testによる演算後、zf=0 and sf=0ならばジャンプする。

- jge <jump address>は、cmp・testによる演算後、sf=0ならばジャンプする。

- jc <jump address>は、cmp・testによる演算後、cf=1ならばジャンプする。

- jnc <jump address>は、cmp・testによる演算後、cf=0ならばジャンプする。

- 例

  - if文の例

    ```
    if (x == 0){
        x = 5;
    }
    x = 2;
    
    cmp ptr dword [x] 0
    jnz end_if:
    mov ptr dword [x] 5
    end_if:
    mov ptr dword [x] 2
    ```

  - if-else文の例

    ```
    if (x == 0){
        x = 5;
    } else {
        x = 2;
    }
    
    cmp ptr dword [x] 0
    jne else
    mov ptr dword [x] 5
    jmp end
    
    else:
    mov ptr dword [x] 2
    end:
    ```

  - if-elseif-else文の例

    ```
    if (x == 0){
        x = 5;
    } else if (x == 1) {
        x = 6;
    } else {
    	x = 7
    }
    
    
    cmp ptr dword [x] 0
    jne else_if
    mov ptr dword [x] 5
    jmp end
    
    else_if:
    	cmp ptr dword [x] 1
    	jne else
    	mov ptr dword [x] 6
    	jmp end
    else:
    	mov ptr dword [x] 7
    end:
    ```

  - 練習問題

    ```
    mov dword ptr [ebp-4], 1    //アドレスebp-4の値(A) = 1
    cmp dword ptr [ebp-4], 0    //A - 0 != 0だから、zf = 0
    jnz loc_40101C			   //jump not zeroのため、ジャンプしない
    mov eax, [ebp-4]		   //eax = 1
    xor	eax, 2                  //eax = !(0000 ～ 0001 | 0000 ～ 0010) = 1111　～ 1111 1100  (nor演算 1 1= 0/1 0 = 0/0 1 = 0/0 0 = 1)
    mov [ebp-4], eax		   //A = FF FF FF FC
    jmp loc_401025			   // jump to loc_401025
    
    loc_40101C:
    	mov ecx, [ebp-4]
    	xor ecx, 3
    	mov [ebp-4], ecx
    
    loc_401025:
    
    
    x = 1
    if (x == 0){
    	x = x ^ 2 
    }else{
        x = x ^ 3
    }
    ```


### 4-7 ループ

- ```
  mov [i], 0
  
  whille_start:
  	cmp [i], 5
  	jge	end
  	mov eax, [i]
  	add eax, i
  	mov [i], eax
  	jmp while_start
  end:
  
  //C言語 for
  for (initialization; condition; update_statement) {
  	block of code
  }
  
  //C言語 while
  initialization
  while (condition){
  	block of code
  	update_statement
  }
  
  ```

- ```
  //アセンブリコード練習問題
  mov dword ptr [ebp-8], 1 		// *ebp-8 = 1
  mov dword ptr [ebp-4], 0		// *ebp-4 = 0
  
  loc_401014:
  	cmp dword ptr [ebp-4], 4	// *ebp-4 > 4  
  	jge short loc_40102E		// if *ebp-4 > 4 → loc_40102E
  	mov eax, [ebp-8]			// eax = *(ebp-8)
  	add eax, [ebp-4]			// eax += *(ebp-4)
  	mov [ebp-8], eax			// *(ebp-8) = eax
  	mov ecx, [ebp-4]			// ecx = *(ebp-4)
  	add ecx, 1					// ecx += 1
  	mov [ebp-4], ecx			// *(ebp-4) = ecx
  	jmp short loc401014			// loc_401014
  
  loc_40102E
  
  // for文
  for (int i = 0;int j = i; i < 4; i++){
  	j += i
  }
  
  // while文
  int a = 1;
  int i = 0;
  
  while (i < 4){
  	a = a + 1;
  	i++;
  }
  ```

### 4-8 関数

- **スタック**

  - OSにより割り当てられるメモリ領域の一種で、LIFO(Last In First Out)方式を採用している。
  - スタックは上位アドレス→下位アドレスに向かって積み上げていく。
  - **ESP**はスタックの先頭(スタックの中で最下位アドレス)を指す。
  - push valueは、スタックポインタのアドレスを-4し、スタックの先頭にvalueを保存する。
  - pop registerは、スタックポインタのアドレスを+4し、スタックの先頭をレジスタへ格納する。

- **関数の利用方法**

  - call <関数のアドレス>で関数が呼ばれる。
  - この際に、次の命令が格納されたリターンアドレスをスタックにプッシュする。
  - また、関数の呼び出し元に戻るためにはret命令を使用する。
  - この際に、スタックの先頭からアドレスをEIPレジスタに格納し、そのアドレスに対して移動する。

- **関数パラメータと戻り値**

  - 関数が受け取るパラメータはスタックにプッシュされ、戻り値がEAXレジスタに格納される。

    ```c
    // C言語
    int test(int a, int b)
    {
    	int x, y;
    	x = a;
    	y = b;
    	return 0;
    }
    
    int main()
    {
    	test(2, 3);
    	return 0;
    }
    
    // アセンブリ言語
    push 3			//引数b この時espは-4される。
    push 2			//引数a この時espは-4される。
    call test		//test関数の実行 この時espは-4される。
    add esp, 8		//
    xor, eax, eax	//eax = 0
        
        
    test:
    	push ebp			//スタックにebpをpush、前スタックのebpの保存をする。esp-4
    	mov ebp, esp		//ebp = esp、新スタックのebpを現在のespで更新する。
            // 上記二つの処理を関数プロローグといい、関数の準備(=新スタックの作成)を行っている。
    	sub esp, 8			//esp = esp - 8, ローカル変数用のスペースを空ける。
    	mov eax, [ebp+8]　　 //eax = *(ebp+8), 変数aの取得
    	mov [ebp-4], eax	//*(ebp-4) = eax = *(ebp+8) = 変数a
    	mov ecx, [ebp+0Ch]	//ecx = *(ebp+12) = 変数b
       	mov [ebp-8], ecx	//*(ebp+8) = ecx = 変数b
      	xor eax, eax		//eax = 0
      	mov esp, ebp		//esp = ebp, 新スタックの削除
      	pop ebp				//ebp = esp:esp-4, esp+4, 旧スタックのebpの取得
            // 上記二つの処理を関数エピローグといい、関数の終了(新スタックの終了)を行っている。
      	ret					//eip = esp:esp-4
    ```

- **cdecl呼び出し規約**

  - 呼び出し元関数は、引数の右から左へパラメータをスタックへプッシュする。
  - 関数を呼び出す。
  - 呼び出し先関数は、引数分のスペースをスタックに空ける。
  - 呼び出し先関数は、前のスタックから引数を取り出し、現在のスタックへと格納する。
  - 呼び出し先関数は、スタックを削除し、ebp・eip・espを前のスタックの状態へと戻す。
  - **cdecl**呼び出し規約以外にも、**stdcall**呼び出し規約(DLLによりエクスポートされた関数)や**fastcall**呼び出し規約(64bitプログラム)がある。

### 4-9 配列と文字列

- 配列名は、配列の最初の要素を指すポインタ定数である。

- 配列内要素は次の三要素を用いて計算される。

  - 配列のベースアドレス+要素のインデックス*配列の各要素のサイズ

- **練習問題**

  ```c
  push ebp						// ebpの値をスタックへ, esp-4		
  mov ebp, esp					// ebp = esp
  sub esp, 14h					// esp = esp - 14h(20バイト)
  mov dword ptr [ebp-14h], 1		// *(ebp-14h) = 1, 14h = 20 		
  mov dword ptr [ebp-10h], 2		// *(ebp-10h) = 2, 10h = 16
  mov dword ptr [ebp-0Ch], 3		// *(ebp-0Ch) = 3, 0Ch = 12
  mov dword ptr [ebp-4], 0		// *(ebp-4h) = 0, 4 = 4
      
  loc_401022:
  	cmp dword ptr [ebp-4], 3	// ebp-4が3以上ならばジャンプする。
      jge loc_40103D				// 
      mov eax, [ebp-4]			// eax = *(ebp-4)
      mov ecx, [ebp+eax*4-14h]	// ecx = *() 
      mov [ebp-8], ecx			
  ```

- **文字列**

  - 文字列は文字の配列で、最後の要素にNULL終端要素が追加される。

- **文字列命令**

  - x86のプロセッサ群は、文字列を操作できる文字列命令を提供している。
  - これらの命令は、文字列を操作し、b・w・dの接尾辞がついている。
  - レジスタはEAX・ESI・EDIを用いる。
    - EAXは、値を保持するために使用する。
    - ESIは、操作元の文字列アドレスを保持するために使用する。自動的にインクリメントないしはデクリメントされる。
    - EDIは、操作先の文字列アドレスレジスタとして使用する。自動的にインクリメントないしはデクリメントされる。

  - eflagsレジスタ内にある方向フラグdfは、ESI・EDIをインクリメントするか、デクリメントするかを決定する。
  - CLD命令は、方向フラグをクリアする。

- **movsx命令**

  - movsx命令は、バイトシーケンスをあるメモリ位置から別のメモリ命令に移動するために利用される。
  - movsb命令は、ESIレジスタで指定されたアドレスからEDIレジスタで指定されたアドレスに1バイト分移動する。
  - movsw命令・movsd命令は、ESIで指定されたアドレスからESIで指定されたアドレスに、それぞれ2バイト・4バイト移動する。

- **命令コードの繰り返し(REP)**

  - movsx命令では出来ないマルチバイトのコピーを行う場合に使用する。
  - rep命令は、ECXレジスタで指定された回数だけ文字列の命令コードを繰り返す。

- **レジスタからメモリへの値の保存(STOSX)**

  - STOSB命令は、CPUのALレジスタからEDIで指定されたメモリアドレスへバイト移動するために利用される。
  - 同様に、STOSW命令とSTOSD命令は、2バイト・4バイトからEDIで指定されたアドレスにデータを移動する。

- **メモリからレジスタへ読み込み(LODSX)**

  - LODSB命令は、ESI(Source Index Register)で指定されたメモリアドレスからALレジスタにバイトを移動する。
  - 同様に、ESIで指定されたメモリアドレスから2バイト・4バイトのデータを移動する。

- **メモリのスキャン(SCASX)**

  - SCANSB命令は、バイトシーケンス内の特定のバイト啞チアの有無を検索するために使用する。
  - 検索するバイトはALレジスタに配置され、メモリアドレスはEDIレジスタに配置される。

- **メモリ内の値の比較(CMPSX)**

  - ESIで指定されたメモリアドレスのバイトと、EDIで指定されたメモリアドレスのバイトを比較し、同じデータが含まれているかどうかを判断するために使用する。

### 4-10. 構造体

- **構造体**は、さまざまなタイプのデータをグループ化したものである。

- 構造体の各要素をメンバーという。

  ```c
  struct simpleStruct{
      int a;
      short int b;
      char c;
  }
  
  void update(struct simpleStruct *test_stru_ptr){
      test_stru_ptr-> = 6;
      test_stru_ptr-> = 7;
      test_stru_ptr-> = 'A';
  }
  
  int main(){
      struct simpleStruct test_stru;
      update(&test_stru);
      return 0;
  }
  
  
  push ebp;					// esp+4, ebpをスタックの先頭へ, ebpの保存を行う。
  mov ebp, esp				// ebp = esp, ebpの書き換え
  mov eax, [ebp+8]			// eax = *ebp+8, 引数をeaxへ
  mov dword ptr [eax], 6		// eax = 6
  mov ecx, 7				   // ecx = 7
  mov [eax+4], cx			　　// *eax+4 = cx = 7
  mov byte ptr [eax+6], 41h	// *eax+6 = 41h = A = 65
  mov esp, ebp			　 // esp = ebp, スタックの削除
  pop ebp					　// ebp = former ebp
  ret
  ```

### 4-11. x64アーキテクチャ

- **x64とx86のアーキテクチャの違い**
  - レジスタが32bit→64bitとなり、レジスタ名が異なる事
    - EAX→RAXなど
  - 8つの新しいレジスタが存在する事(R8～R15)
  - 64bitデータを処理できるようになった事
  - RIP相対アドレス指定をサポートしている事
    - RIPレジスタを利用して、メモリの場所を参照できるようになった事
  - 呼び出し規約が変更になった事
    - x86がパラメータをスタックにプッシュしていたのに対して、x64は最初の4つのパラメータがRCX・RDX・R8・R9レジスタに渡され、さらにパラメータが存在している場合にのみスタックにプッシュするようになった。

## 第五章 IDAによる逆アセンブル

### 5-0. 概要

- アセンブリコードの分析を簡単に行うため、IDA Proは様々な機能を使用する事が出来る。

### 5-1. コード解析ツール

- **逆アセンブラ**
  - マシンコードをアセンブリコードに変換するプログラム
  - 主に、プログラムを実施せず、コードを解釈する静的コード解析のために使用する。
- **デバッガ**
  - マシンコードを逆アセンブルするプログラムだが、全体の実行だけでなく単一の命令・選択した関数を実行する事が出来る。
  - 主に、プログラムを実行してコードの内容を理解する動的コード解析を実行する事が出来る。
- **逆コンパイラ**
  - マシンコードを高級言語に変換するプログラムである。

### 5-2. IDAによる静的コード解析

- **逆アセンブルウィンドウ**

  - 逆アセンブルしたコードを表示する。

  - **グラフビュー**

    - フローチャート形式で関数を表示する。
    - 分岐やループを素早く認識するのに役立つ。
      - 緑の矢印
        - 条件が真の場合にジャンプが実施される事を示す。
      - 赤の矢印
        - 条件が偽の場合にジャンプが実施される事を示す。
      - 青の矢印
        - 無条件ジャンプを示す。
        - また、上方向への青矢印はループを示す。

  - **テキストビュー**

    - 逆アセンブル全体が一列に表示される。
    - 仮想アドレスは、セクション名: 仮想アドレスという形式で表示される。
    - 破線矢印
      - 条件付きジャンプ
    - 実線矢印
      - 無条件ジャンプ

- **関数ウィンドウ**

  - 各関数を特定できる仮想アドレス、各関数のサイズ、プロパティなどがわかる。
  - 各フラグは以下のように定義されており、特にLフラグはコンパイラにより生成されたものであるので解析しないようにする。

- **出力ウィンドウ**

  - IDAによって生成されたメッセージが表示される。

- **16進数ウィンドウ**

  - バイトシーケンスが16進数ダンプ形式とASCII形式で表示される。

- **構造ウィンドウ**

  - プログラム内で利用される標準データ構造のレイアウトが一覧で表示される。

- **インポートウィンドウ**

  - プログラムによってインポートされたすべての関数が一覧表示される。

- **エクスポートウィンドウ**

  - プログラムからエクスポートされている関数を一覧表示する。

- **文字列ウィンドウ**

  - ファイルから抽出された文字列リストとそれが存在するアドレスが表示される。

- **セグメントウィンドウ**

  - 実行ファイル内のセクション名・開始/終了アドレスが記載される。

- **練習問題1**
  - 入力
    ```c
    int main(){
    	int x = 1;
      int y;
    	y = x;
    	return 0;
    }
    ```

  - 出力
    ```
    ; Attributes: bp-based frame fuzzy-sp　EBPベースのスタックフレームが使用されている。
    
    ; int __cdecl main(int argc, const char **argv, const char **envp) # 関数プロトタイプの検出
    public _main
    _main proc near
    
    argc= dword ptr  8				# ローカル変数の特定
    argv= dword ptr  0Ch
    envp= dword ptr  10h
    
    push    ebp						# ebpの保存
    mov     ebp, esp				# ebp = esp 
    and     esp, 0FFFFFFF0h			# espのand演算 
    sub     esp, 10h				# esp = esp - 10h(16)
    call    ___main					# main関数の呼び出し
    mov     dword ptr [esp+0Ch], 1	 # *esp+12 = 1 
    mov     eax, [esp+0Ch]			# eax = *esp+12 = 1
    mov     [esp+8], eax			# *esp+8 = 1 = eax
    mov     eax, 0					# eax = 0
    leave
    retn
    _main endp
    ```

- **練習問題2**
  - 入力
    ```c
    int a;
    char b;
    int main(){
    	a = 41;
      b = 'A';
      int x = a;
      int *y = &a;
      char *string = "test";
      return 0;
    }
    ```

  - 出力
    ```
    ; int __cdecl main(int argc, const char **argv, const char **envp)
    public _main  
    _main proc near

    argc= dword ptr  8
    argv= dword ptr  0Ch
    envp= dword ptr  10h

    push    ebp               ;ベースポインタのプッシュ
    mov     ebp, esp          ;ebp = esp　ベースポインタの更新
    and     esp, 0FFFFFFF0h   ;esp = 0FFFFFFFF0h  スタックポインタの更新
    sub     esp, 10h          ;esp = esp - 10h  スタックを16バイト先に進める。
    call    ___main           ;__main関数の呼び出し
    mov     ds:_a, 29h        ; ds:_a = 29h = 41
    mov     ds:_b, 41h        ; ds:_b = 41h = 65 = A
    mov     eax, ds:_a        ; eax = ds:_a 
    mov     [esp+0Ch], eax    ; *(esp+0Ch) = *(esp+12) = eax = ds:_a = 41 → x = a
    mov     dword ptr [esp+8], offset _a              ; *(esp+8) = offset _a → *y = &a
    mov     dword ptr [esp+4], offset aTest ; "test"  ; *(esp+4) = offset aTest → *string = &test
    mov     eax, 0            ; eax = 0
    leave                     ; 
    retn
    _main endp
    ```
    

### 5-3. Windows APIの逆アセンブル

### 5-4. IDAによるプログラムへのパッチ適用

### 5-5. IDAスクリプトとプラグイン

### 5-6. まとめ

## TODO

- 表層解析をまとめたPythonツールを作成する。
- FLOSSのコードを見てみる。
- UPXを調べる。
- Pythonのpefileライブラリを使用してみる。