# 実践バイナリ解析 

## 第1章 バイナリを解剖する

### 1.0 概要

- 本章では、バイナリフォーマットを解剖し、バイナリのライフサイクルを調べる。
- **バイナリ**は、0と1の二進数を指し、**バイナリコード**はシステムが実行できるマシンコードを指す。
- つまり、**バイナリコード**はある一定の規則に基づいて書かれたコードであり、その規則が**ELFフォーマット**、または**PFファイルフォーマット**の違いである。

### 1.1 Cのコンパイルプロセス

- **Cのコンパイルプロセス**は、以下の4つのフェーズに分かれる。
  - **前処理フェーズ**
    - #includeディレクティブのヘッダーファイル(型定義・グローバル変数・関数プロトタイプが定義されている)と#defineディレクティブ(マクロが定義されている)をコンパイル対象のソースファイルに展開する。
  - **コンパイルフェーズ**
    - 前処理済みのコードをアセンブリ言語に変換する。
      - 何故マシンコードではなく、アセンブリ言語を出力するのか?
        - 他の言語(Delpi, C++, Objective-C, Common Lispなど)も同じくアセンブリ言語を出力する設計になっており、アセンブリ言語からマシンコードの出力は共通のアプリケーションを使用して実施するため。
    - またこの際に、最適化も行う。
  - **アセンブル**
    - アセンブリ言語からオブジェクトファイルを出力する。また、ソースファイルはそれぞれ一つのアセンブリファイルに対応している。
    - gcc -c でコンパイル後は**ELF 64-bit LSB relocatable**と出力される事がある。
      - **ELF**は、ELFファイルである事を示す。
      - **64bit**は、x86-64でコンパイルされている事を示す。
      - **LSB**は、Least Significant Bitである(数字の最下位バイトが先頭に来るように数字が並んでいる)事を示す。(=リトルエンディアン)
      - **relocatable**は、再配置可能(メモリ内の特定のアドレスに配置される事を前提としていない)を示す。
  - **リンク**
    - 全てのオブジェクトファイルをつなぎ合わせて、一つのバイナリ実行ファイルを作成する。
    - リンクフェーズを実行するプログラムをリンクエディタという。
    - 実行ファイルがメモリアドレスに読み込まれる時、初めて再配置シンボルが特定のアドレスを持つ事になり参照をリンカが解決できるようになる。

### 1.2 シンボルとストリップされたバイナリ

- **シンボル情報**
  - シンボルとは、変数や関数に対してどのバイナリコードやデータが対応するのかを読みやすくするためにコンパイラが生成したものである。
  - シンボルファイルは、商用製品やマルウェアなどでは削除される事が主である。

- **バイナリのストリップ**
  - stripコマンドによって、バイナリをメモリに読み込む時に使用する動的な依存関係を解決するシンボル以外は削除されてしまう。

### 1.3 バイナリを逆アセンブルする

- **objdump**

  - ```cmd
    $ objdump -sj .rodata compilation_example.o
    ```

    - .rodataセクション(read only dataセクション)のみを表示している。

  - ```cmd
    $ objdump -M intel -d compilation_example.o
    ```


### 1.4 バイナリを読み込んで実行する

1. プログラムを実行するための新しいプロセスの準備
2. 仮想メモリへのインタープリタの読み込み
   - インタープリタは、バイナリを読み込んで再配置を行うプログラムである。
   - Linuxでは、ld-linux.soという共有ライブラリである。
     - ELFバイナリの.interpセクションには、バイナリの読み込みに使用されるインタープリタのパスを指定する事が出来る。
   - また、Windowsでは、ntdll.dllの一部としてインタープリタは実装されている。
3. インタープリタによるバイナリの読み込み
4. インタープリタによるバイナリのパースと動的ライブラリの割り出し
5. インタープリタによるライブラリの仮想空間に対する読み込み
6. インタープリタによるバイナリコードセクションの動的ライブラリに対する参照解決
   - インタープリタはバイナリを読み込んだ直後に、**これらの参照を解決するのではなく関数が呼び出されるまで先送りする遅延バインディング**を採用している。

### 1.5 まとめ

- 事象から具体的なバイナリフォーマットを見ていく。

## 第2章 ELFフォーマット

### 2.0 概要

- ELFは、実行ファイル・オブジェクトファイル・共有ライブラリ・コアダンプに使用される。
- ELFファイルは、以下の四つの構成要素からなる。
  - 実行可能ヘッダー
  - プログラムヘッダー
  - セクション
  - セクションヘッダー

### 2.1 実行可能ヘッダー

- 実行可能ヘッダーの役割は、そのファイルがELFファイルである事、そのELFファイルの種類、ファイル内にある情報の全ての場所を明確にするという役割がある。

  ```c
  typedef struct {
      unsigned char e_ident[16];	
      	/*
      		0～3バイト	このファイルがELFバイナリである事を示す"0x7fELF"の文字列が入る
      		4バイト目	EI_CLASS: このバイナリが32bit(1), 64bit(2)どちらに対応しているか
      		5バイト目	EI_DATA: このバイナリがリトルエンディアン(1)、ビッグエンディアン(2)どちらに対応しているか
      		6バイト目	EI_VERSION: このバイナリ作成時のELFバージョン
      		7バイト目	EI_OSABI: このバイナリのコンパイル時にターゲットとしてしてされたABIの情報
      		8バイト目	EI_ABIVERSION: このバイナリのコンパイル時にターゲットとしてしてされたOSの情報
      		9～15バイト	EI_PAD: パディング扱い, 将来の拡張用
      	*/
      uint16_t e_type;
      	/*
      		e_type: バイナリの種類が指定される。
      			ET_REL:	 再配置可能なオブジェクトファイル
      			ET_EXEC: 実行可能バイナリ
      			ET_DYN:	 動的ライブラリ
      	*/
      uint16_t e_machine;
          /*
      		e_machine: バイナリを実行するアーキテクチャが指定される。
      			EM_X86_64: 64bit x86 
      			EM_386:	   32bit x86
      			EM_ARM:    ARMバイナリ
      	*/
      uint32_t e_version;
      	/*
      		e_version: バイナリ作成時のELFバージョン
      			EV_CURRENT: バージョン1
      	*/
      uint64_t e_entry;
      	/*
      		e_entry: バイナリのエントリポイント(=実行を開始するべき仮想アドレス)
      	*/
      uint64_t e_phoff;
      	/*
      		e_phoff: プログラムヘッダーテーブルの先頭に対するファイルオフセット
      				 0だとプログラムヘッダーテーブルがない事を意味する。
      	*/
      uint64_t e_shoff;
          /*
      		e_shoff: セクションヘッダーテーブルの先頭に対するファイルオフセット
    				 0だとセクションヘッダーテーブルがない事を意味する。
      	*/
      uint64_t e_flags;
      	/*
      		e_flags: ターゲットアーキテクチャの固有のフラグを表す。
      				x86の場合、基本的に0である。
      	*/
      uint16_t e_ehsize;
      	/*
      		e_ehsize: 実行可能ヘッダーの大きさをバイト数で指定する。
      		　　　　　 64bitx86バイナリの場合は、実行可能ヘッダーの際は64バイト
      		　　　　　 32bitx86バイナリの場合は、実行可能ヘッダーの際は52バイト
      	*/
      uint16_t e_phentsize;
      	/*
      		e_phentsize: プログラムヘッダーテーブルのサイズ
      	*/
      uint16_t e_phnum;
      	/*
      		e_phentsize: プログラムヘッダーテーブルの個数
      	*/
      uint16_t e_shentsize;
      	/*
      		e_shentsize: セクションヘッダーテーブルのサイズ
      	*/
      uint16_t e_shnum;
      	/*
      		e_shnum: セクションヘッダーテーブルの個数
      	*/
      uint16_t e_shstrndx;
      	/*
      		e_shstrndx: 文字列テーブルセクションに関連するヘッダーのインデックスが含まれている。
      	*/
  } Elf64_Ehdr;
  ```

### 2.2 セクションヘッダー

- ELFバイナリのコードとデータは、セクションと呼ばれる連続するチャンクに論理的に分割される。

- セクションヘッダーはセクションに属しているバイトを特定できるようにするためのものである。

- セクションヘッダーテーブルには、バイナリ内の全てのセクションに対するセクションヘッダーが含まれている。

- セグメントはバイナリのコードとデータを別々に分けるための論理的な構造である。

- セクションは、リンク時のみに存在する構造であり実行時には存在しない。

  ```c
  typedef struct{
      uint32_t sh_name;
      	/*
      		sh_name: セクション名が指定されている。0の場合はセクション名がない事を指す。
      	*/
      uint32_t sh_type;
          /*
      		sh_type: セクションタイプが指定されている。
      			SHT_PROGBITS:	マシン命令や定数といったプログラムデータを含んでいる。
      			SHT_SYMTAB:		静的シンボルテーブル
      			SHT_DYNSYM:		動的リンカーが使用するシンボルテーブル
      			SHT_STRTAB:		文字列テーブル, NULL終端待ち文字列の配列となっており、一文字目はNULLとなっている。
      			SHT_REL:		再配置可能エントリ	
    			SHT_RELA:		再配置可能エントリ
      			SHT_DYNAMIC:	動的にリンクに必要な情報
      	*/
      uint64_t sh_flags;
      	/*
      		sh_flags:	セクションフラグ
      			SHF_WRITE: 		セクションが実行時に書き込み可能である事を示す。(=変数を含むかどうか)
      			SHF_ALLOC: 		バイナリ実行時にセクションの内容が仮想メモリに読み込まれる事を示す。
      			SHF_EXECINSTR: 	セクションに実行可能な命令が含まれている事を示す。
      	*/
      uint64_t sh_addr;
      	/*
      		sh_addr: セクションの仮想アドレス
      	*/
      uint64_t sh_offset;
      	/*
      		sh_offset: セクションのファイルオフセット
      	*/
      uint64_t sh_size;
      	/*
      		sh_size: セクションのサイズ
      	*/
      uint32_t sh_link;
      	/*
      		sh_link: 関連するセクションのインデックスを指定する。
      	*/
      uint32_t sh_info;
      	/*
      		sh_info: セクションに関する追加情報
      	*/
      uint64_t sh_addralign;
      	/*
      		sh_addralinn:	アラインメント
      	*/
      uint64_t sh_entsize;
      	/*
      		sh_entsize:	明確に定義された構造に対する各エントリサイズをバイト数で指定する、
      	*/
  } Elf64_Shdr;
  ```

### 2.3 セクション
- **遅延バインディング**
	- アドレス解決が未解決の場所が最初に参照される時までアドレス解決が先送りされる処理を指す。
	- このようにアドレス解決を先送りにする事で、実行時に本当に必要な再配置のみを実施する事が出来る。
	- 遅延バインディングを実施するために、**.pltセクション(Procedure Linkage Table)**と **.gotセクション(Global Offset Table)**と **.got.pltセクション**を使用する。
	- 遅延バインディングの具体的な実行手順は以下の通りである。
		1. コードセクションにおいて、共通ライブラリの関数をコールする。
			- e.g. call puts@plt
		2. .got.pltテーブルに存在するアドレスにジャンプする。
			- e.g. jmp QWORD PTR [rip+0x2000c12]
		3. .got.pltテーブルにおいて、pushしてスタックを作成する。
			この際にpushする整数はPLTスタブのIDである。
			- e.g. push 0x0
		4. デフォルトスタブへジャンプする。
		   デフォルトスタブは全てのPLT関数スタブが共有するスタブの事を指す。
			- e.g. jmp <default stub>
		5. GOTから取得した実行ファイルそのものを識別するIDをプッシュし、動的リンカ―にジャンプする。
	- GOTが必要な理由は以下の通りである。
		1. GOTは読み取り・書き込み可能なセクションであり、書き込み可能なコードセクションを作らずに動的リンカ―を形成出来るため
		2. 共通ライブラリはプロセスごとではなく、全てのプロセスで共通化する傾向にある。仮想アドレスの範囲が各プロセスに依存しているため、GOTを使用して間接化する必要がある。


- **.initセクション**
  - 初期化を行う実行可能コードが含まれている。
  - .initセクションのコードは、バイナリに含まれている他のコードよりも先に実行する必要がある。
  - システムは、バイナリのメインエントリポイントに制御を移す前に.initセクションのコードを実行する。

- **.finitセクション**
  - .finitセクションはメインエントリポイントが完了した後に実行される。

- **.textセクション**
  - プログラムのメインコードを含んでいるセクションである。
  - 一般的に実行可能なセクションが書き込み可能セクションであると脆弱性となる事が多い。
  - .textセクションのエントリポイントは_startセクションになる事が多い。

- **.bssセクション**
  - コードセクションは書き込み不可能であるため、変数は一つ以上の特別な書き込み可能セクションに格納される。
  - .bssセクションは、初期化されていない変数を格納するための場所である。

- **.dataセクション**
  - 初期化された変数のデフォルト値が格納されるセクションである。
  - また、変数の値は実行時に変化する事があるため、本セクションは書き込み可能である。

- **.rodataセクション**
  - .read only data セクションの略で、主に定数値の格納を目的とするセクションである。

- **.pltセクション**
  - 遅延バインディングを実施するために使用するセクションである。

- **.gotセクション**
  - 遅延バインディングを実施するために使用するセクションである。

- **.rel.*セクション**

- **.rela.*セクション**

- **.dynamicセクション**

- **.init_arrayセクション**

- **.fini_arrayセクション**

- **.shstrtabセクション**

- **.symtabセクション**

- **.strtabセクション**

- **.dynsymセクション**

- **.dynstrセクション**

### 2.4 プログラムヘッダー

- **p_typeフィールド**

- **p_flagsフィールド**

- **p_offsetフィールド**

- **p_vaddrフィールド**

- **p_paddrフィールド**

- **p_fileszフィールド**

- **p_memszフィールド**

- **p_alignフィールド**



### 2.5 まとめ


## 自己調査






