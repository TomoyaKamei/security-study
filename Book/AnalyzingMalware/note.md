# アナライジングマルウェア



## 第1章ファイルをダウンロードするマルウェアの解析


## 第2章 パックされているマルウェアの解析

### 2.1 はじめに
- パッカーは、プログラムの実行形式を保ったまま圧縮・難読化するツールの事である。
- パッカーは、本来のコード部分を実行する前に、圧縮・難読化されたコードを展開するための処理が実行される。

### 2.2 PEファイルフォーマット
- **2.2.0 概要**
    - PEファイルフォーマットは、ローダがプログラムをロードするのに必要な情報が格納されたヘッダとプログラムコードやリソースデータなどが記録されているセクションで構成されている。
    - ヘッダ
        - DOS MZヘッダ
        - DOSスタブ
        - PEヘッダ
        - セクションテーブル
    - セクション
    - RVA(Relative Virtual Address; 相対仮想アドレス)
        - プログラムがメモリロードされたアドレスからの相対アドレス

- **2.2.1 DOS MZヘッダ/DOSスタブ**
    - DOS MZヘッダは。IMAGE_DOS_HEADERとして定義されている。
    - DOS MZヘッダのサイズは64バイトで、19個のメンバから構成されている。
    ```
    typedef struct _IMAGE_DOS_HEADER {
        WORD    e_magic;    // Windows実行ファイルの場合は0x4D, 0x5A(MZ)となる。
        WORD    e_cblp;
        WORD    e_cp;
        WORD    e_crlc;
        WORD    e_cparhdr;
        WORD    e_minalloc;
        WORD    e_maxalloc;
        WORD    e_ss;
        WORD    e_sp;
        WORD    e_csum;
        WORD    e_ip;
        WORD    e_cs;
        WORD    e_lfarlc;
        WORD    e_ovno;
        WORD    e_res[4];
        WORD    e_oemid;
        WORD    e_oeinfo;
        WORD    e_res2[10];
        WORD    e_lfanew;  // PEヘッダへのオフセット値(PEヘッダが開始されるアドレス)
    } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
    ```
    - DOSスタブは、DOS MZヘッダの次の領域で、通常は"This program cannot be run in DOS mode"と表示されるように文字列などが配置されている。

- **2.2.2 PEヘッダ**
    - PEヘッダは、IMAGE_NT_HEADERSとして定義されており、Signature・FileHeader・OptionalHeaderの3つのメンバから構成されている。
    ```
    typedef struct _IMAGE_NT_HEADERS{
        DWORD Signature;                        // PEヘッダの先頭4バイトでPE(0x50, 0x45, 0x00, 0x00)が入る。 
        IMAGE_FILE_HEADER FileHeader;           // ファイルヘッダ
        IMAGE_OPTIONAL_HEADER32 OptionalHeader; // オプショナルヘッダ
    } IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;

    typedef struct _IMAGE_FILE_HEADER{
        WORD    Machine;
        WORD    NumberOfSections;               // セクションの数を示す値
        DWORD   TimeDateStamp;                  
        DWORD   PointerToSymbolTable;
        DWORD   NumberOfSymbols;
        WORD    SizeOfOptionalHeader;           // OptionalHeaderのサイズ
        WORD    Characteristics;                // ファイルの属性を表すフラグ値の論理和
    } IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

    typedef struct _IMAGE_OPTIONAL_HEADER {
        WORD    Magic;
        BYTE    MajorLinkerVersion;
        BYTE    MinorLinkerVersion;
        DWORD   SizeOfCode;
        DWORD   SizeOfInitializedData;
        DWORD   SizeOfUninitalizedData;
        DWORD   AddressOfEntryPoint;            // プログラムの実行開始アドレス(RVA)
        DWORD   BaseOfCode;
        DWORD   BaseOfData;
        DWORD   ImageBase;                      // プログラムがメモリ上にロードされる時の理想的な開始アドレス(実行ファイル: 0x00400000, DLL: 0x10000000)
        DWORD   SectionAlignment;               // メモリ上にロードされる時に各セクションが配置されるアラインメント(各セクションの開始アドレスがSectionAlignmentの倍数になる。)
        DWORD   FileAlignment;                  // ディスク上で各セクションが配置されるアラインメント(各セクションの開始アドレスがFileAlignmentの倍数になる。)
        WORD    MajorOperatingSysmtemVersion;
        WORD    MinorOperatingSysmtemVersion;
        WORD    MajorImageVersion;
        WORD    MinorImageVersion;
        WORD    MajorSubsystemVersion;
        WORD    MajorSubsystemVersion;
        DWORD   Win32VersionValue;
        DWORD   SizeOfImage;                    // メモリ上にロードされたプログラムのサイズ
        DWORD   SizeOfHeaders;
        DWORD   CheckSum;
        WORD    Subsystem;
        WORD    DllCharacteristics;
        DWORD   SizeOfStackReserve;
        DWORD   SizeOfStackCommit;
        DWORD   SizeOfHeapReserve;
        DWORD   SizeOfHeapCommit;
        DWORD   LoaderFlags;
        DWORD   NumberOfRvaAndSizes;            // IMAGE_DATA_DIRECTORY構造体の配列。インポートしている関数やエクスポートしている関数の情報などを参照するためのテーブルの位置とサイズ構成されている
        IMAGE_DATA_DIRECTORY DataDirectory[16];
    }

    typedef struct _IMAGE_DATA_DIRECTORY {
        DWORD   VirtualAddress;
        DWORD   Size;
    }
    ```

- **2.2.3 セクションテーブル**
    - セクションテーブルは、IMAGE_SECTION_HEADERとして定義されており、セクションのサイズや開始アドレス、属性などを指定している。
    ```
    typedef struct _IMAGE_SECTION_HEADER {
        BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];  // セクションに付けられる名前
        union   {
            DWORD   PhysicalAddress;
            DWORD   VirtualSize;                // プログラムがメモリ上にロードされた時のセクションのサイズ
        } Misc;
        DWORD   VirtualAddress;                 // プログラムがメモリ表にロードされた時のセクション先頭アドレスのRVA
        DWORD   SizeOfRawData;                  // ディスク上に置けるセクションのサイズ
        DWORD   PointerToRawData;               // ディスク上に置けるセクションの先頭へのオフセット
        DWORD   PointerToRelocations;
        DWORD   PointerToLinenumbers;
        WORD    NumberOfRelocations;
        WORD    NumberOfLinenumbers;
        DWORD   Characteristics;                // セクションの属性を表すフラグ値の論理値
    } IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;
    ```

- **2.2.4 セクション**
    - セクションには、役割に応じていくつかの種類が存在する。
        - コードセクション
        - データセクション
        - リソースセクション
        - エクスポートセクション
        - インポートセクション
        - TLS(Thread Local Storage)セクション
    - **インポートセクション**
        - インポートセクションにおいては、外部DLLからインポートする関数の情報が含まれている。
        - インポートテーブルは、IMAGE_IMPORT_DESCRIPTOR構造体の配列として定義されている。
        - インポートテーブルの終端は、全てのフィールドが0で埋められたIMAGE_IMPORT_DESCRIPTORで表現される。
            ```
            typedef struct _IMAGE_IMPORT_DESCRIPTOR {
                union {
                    DWORD Characteristics;      
                    DWORD OriginalFirstThunk;   // Import LookUp Table(ILA)のRelative Virtual Address(RVA)、ILAはIMAGE_THUNK_DATA構造体の配列である。
                }

                DWORD   TimeDateStamp;
                DWORD   ForwarderChain;
                DWORD   Name;                   // ImportしているDLL名のRVA
                DWORD   FirstThunk;             // Import Address Table(IAT)のRelative Virtual Address(RVA)、プログラムロード前まではILTと同じである。
            } IMAGE_IMPORT_DESCRIPTOR;
            
            typedef struct _IMAGE_THUNK_DATA32 {
                union {
                    DWORD ForwarderString;
                    DWORD Function;
                    DWORD Ordinal;
                    DWORD AddressOfData;        // IMAGE_IMPORT_BY_NAME構造体へのポインタ
                } u1;
            } IMAGE_THUNK_DATA32


            typedef struct _IMAGE_IMPORT_BY_NAME{
                WORD Hint;      // インポートする関数のヒント
                BYTE Name[1];   ・・
            } IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;
            ```

- **2.2.5 PEhファイルフォーマットを確認するツール**
    - LordPEやdumpbinがツールとしては存在する。

### 2.3 パック
- **2.3.1 パックされたプログラムの特徴**
    1. インポートされているAPIの数が少ない。
    2. 意味のある文字列が見当たらない。
    3. セクション名が変更される。

- **2.3.2 パックされたプログラムの実行フロー**
    - パックされたプログラムは、復号化用のプログラムがエントリポイント付近に追加されている。
    - 基本的な戦略は以下の通りである。
        1. 実行ファイルの展開ルーチンが実行される。
        2. パックされたコードがメモリに展開される。
        3. 展開されたコードのIATを再構築する。
            - 展開されたコードがインポートしている関数を呼び出せるようにローダが本来行うIATの書き換え処理を展開ルーチンの中で実行する必要がある。
        4. 展開されたコードを実行する。
- **2.3.3 自作パッカーで動作を理解する**
    - 本パッカーは、コード領域をXORでエンコードするのみである。
    ```c
    #include <stdio.h>
    #include <windows.h>

    // デコードするためのコード
    unsigned char decode_stub[] = {
        0x60,                               // pushad;                  展開ルーチンの始動
        0xBE,0xFF,0xFF,0xFF,0xFF,           // mov esi, decode_start;   展開ルーチンのアドレスをesiに格納 
        0xB9,0xFF,0xFF,0xFF,0xFF,           // mov ecx, decode_size;    展開後のコードサイズをecxに格納
        0x81,0xC6,0xFF,0xFF,0xFF,0xFF,      // add esi, base_addr;      展開ルーチンのアドレスに基底アドレスを追加
        0xB0,0xFF,                          // mov al, decoder;         alにxorの対象となるコードを格納
        0x30,0x06,                          // xor byte ptr [esi], al;  xor [esi] decoder
        0x46,                               // inc esi;                 esiを追加
        0x49,                               // dec ecx;                 esxを減算
        0x75,0xFA,                          // jnz LOOP;                LOOPが0になるまでループ
        0x61,                               // popad;                   ポップ
        0xE9,0xFF,0xFF,0xFF,0xFF,           // jmp OEP, オリジナルエンドポイントへ移動 
    };

    unsigned int decode_start_offset        = 2;
    unsigned int decode_size_offset         = 7;
    unsigned int base_address_offset        = 13;
    unsigned int decoder_offset             = 18;
    unsigned int jmp_oep_addr_offset        = 27;

    void create_decode_stub (
        unsigned int code_vaddr,
        unsigned int code_vsize,
        unsigned int base_addr,
        BYTE decoder,
        unsigned int oep
    )
    {
        int cnt = 0;
        int jmp_len_to_oep = 0; // オリジナルエンドポイントまでのオフセット

        jmp_len_to_oep = oep - (code_vaddr + code_vsize + sizeof(decode_stub));
        
    }
    
    ```

### 2.4 アンパック
- **2.4.1 アンパックに使うツール**
    - パックされているマルウェアを解析するためには、展開ルーチンの処理により複合されたオリジナルコードの抽出が必要になる。
    - アンパックを実行するためには、デバッガ、メモリダンプツール、IAT再構築ツールを使用する。

- **2.4.2 マニュアルアンパック**
    - マニュアルアンパックを実施するためには、以下の手順で実施する。
        1. デバッガでマルウェアを実行し、OEPまで実行する。
            - OEPを見つけ出すためのヒントとして、以下が存在する。
                - pushad命令とpopad命令に着目する。
                - 動的に生成された箇所に制御が移る瞬間に着目する。
                - jmp/call命令に着目する。
                    - 再構築処理を行う過程で同じようなコードを繰り返し実行する箇所が多く存在する。
                    - 
        2. ＯＥＰに到達した後のメモリをダンプし、ファイルに保存する。
        3. ダンプしたファイルのIATを再構築する。
    
- **2.4.3 アンパックの実例**

### 2.5 アンパックを妨害するテクニック
- **2.5.1 Stoken Bytes**
    - 動的に確保された領域にオリジナルコードの一部分をコピーしておき、コピーしたコードを実行した後で元のコードを続けて実行する方法である。

- **2.5.2 SizeOfImageの改変**
    - 

- **2.5.3 Import Redirection**

### 2.6 まとめ

## 第3章 動的解析を妨害するマルウェアの解析

### 3.1 はじめに
- 動的解析は、マルウェアを実際に動かして挙動を感想する手法である。
- 多くのマルウェアは、動的解析を妨げるアンチデバックと呼ばれる機能を有している。
- 動的解析に使用されるツールには以下のようなものがある。
    - 仮想化ソフトウェア
    - システムリソース監視ツール
    - デバッガ

### 3.2 動的解析ツールの検出
- アンチデバッグの種類の一つとして、システムリソースを監視するツールやデバッガの利用を監視し、それらのプロセスを検出する事でそれらを停止させたり、ウィルスの感染動作を停止させる手法が存在する。
- **プロセス一覧から動的解析用のツールを探し出す方法**
    - マルウェアは、プロセス一覧を取得する Windows APIを使用して、デバッガや監視ツールのプロセスを探し出そうとする。
    - ```
    typedef struct tagPROCESSENTRY32 {
        DWORD   dwSize;
        DWORD   cntUsage;
        DWORD   th32ProcessID;
        ULONG_PTR th32DefaultHeapID;
        DWORD   th32MOduleID;
        DWORD   cntThreads;
        LONG    pcProiClassBase;
        DWORD   dwFlags;
        TCHAR   szExeFile[MAX_PATH];    // 実行ファイル名
    } PROCESSENTRY32, *PPROCESSENTRY32;
    ```
    - 回避策としては、実行ファイル名を変更したり、Windows APIであるProcess32FirstがFalseを返すように変更する事でプロセス名の列挙を止める事が可能である。
- **ウィンドウを検出する方法**
    - マルウェアは、監視ツールのウィンドウを探し出す事でデバッガや監視ツールのプロセスの探索を行う事がある。
    - ここでよく使用されるWindows APIとしてGetClassNameやGetWIndowsTextが存在する。
    - 回避策としては、Windows APIが自動的にFalseを返すことが挙げられる。
- **動的解析ツールが利用するデバイスファイルを検出する方法**
    - 各ツール固有のデバイスファイルを作成するものがあり、デバイスの存在を確認する事で監視ツールを検出する事がある。
    - 回避策としては、特定のパスがCreateFileというAPIを使う時にFalseを返すようにする。

### 3.3 タイマーによるチェック
- ここでのアンチデバッグ手法は、実行速度を計測する事で自身が解析されている事を検出する。
- GetTickCountというシステム起動時からの経過時間をミリ秒単位で返すWin32 APIを使用している。
- ここでの回避策として、自動化を実施する事で制限時間内に処理を行う事や、時間を偽る事などが挙げられる。
- また、RDSC命令を使用されるとCPU単位で時間が計測できるため、APIにブレークポイントをしても意味がなくなってしまう。
- この回避策として、まずRSCDC命令を発見したり、RSCDC命令の結果を偽る事が挙げられる。

### 3.4 マルウェア自身の再起動

### 3.5 デバッガの検出

### 3.6 仮想化ソフトウェア上での動作の検出

### 3.7 様々な例外発生への対処

### 3.8 APIに設定されたブレークポイントの検出
