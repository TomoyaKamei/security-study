# Teach Yourself C++



## 第一章 C++の基本的な言語機能


### 1.1 Hello, world
- **1.1.1 はじめてのC++プログラム**
    - ```
    #include <iostream>

    int main(){
        std::cout << "Hello, world" << std.endl;
    }
    
    ```

- **1.1.2 Hello, worldを読み解く**
    - #include命令はヘッダーファイルの読み込みのために使用される。
    - プログラムは値を生成する式(expression)と値を生成しない文(Statement)からなる。


### 1.2 変数と関数
- **1.2.1 変数とは**
    - 変数とは処理の結果を一時的に格納したり、その値を使って別の処理に使用する事が出来る。
    - 変数の宣言は、```変数の型 変数名;```で実施出来る。
    - 変数の宣言と初期化は、```変数の型 変数名 = リテラル;```もしくは```変数の型 変数名 = {リテラル};```もしくは```変数の型 変数名 {リテラル};```もしくは```変数の型 変数名(リテラル);```で実施できる。

- **1.2.2 const修飾子**
    - あとから代入する事が出来ない修飾子を作成するにはconst修飾子を使用する。
    - 宣言方法は、```const 変数型 変数名 = 値;```もしくは```変数型 const 変数名 = 値;```を用いる。
    - const変数は、宣言のみする事は出来ない。

- **1.2.3 関数**
    - 関数とは、複数の処理をまとめた塊で、一度関数を作成し、再利用可能なものである。
    - 宣言方法は、```戻り値型 関数名(引数型 引数名, ...){}```である。


### 1.3 演算子
- **1.3.1 算術演算子**

- **1.3.2 ビット演算子**
    - 2進数に対してのみ対応可能である。

- **1.3.3 sizeof演算子**
    - sizeof演算子は型名から型のサイズを取得する事が可能である。

- **1.3.4 複合代入演算子**

- **1.3.5 演算子の優先順位と結合規則**

### 1.4 条件分岐
- **1.4.1 if文と条件**
    - ```
    #include <iostream>

    int main(){
        int a = 9;
        if (a > 10){
            std::out << "a is more than 10." << std::endl;
        }else{
            std::out << "a is less than 10." << std::endl;
        }

        return 0;
    }
    ```

- **1.4.2 switch文**
    - ```
    #include <iostream>

    int main(){
        int a = 2;
        switch (a + 1){
            case 1:
                std::cout << "a + 1は1です。" << std::endl;
                break;
            case 2:
                std::cout << "a + 1は2です。" << std::endl;
                break;
            case 3:
                std::cout << "a + 1は3です。"  << std::endl;
                break;
            default:
                std::cout << "a + 1は" << a + 1 << "です。" << std::endl;
                break;
        }
        return 0;
    }
    ```
- 三項演算子
    - ```条件 ? 条件が正の時の値 : 条件が負の時の値```

### 1.5 組み込み型とポインタ

- **1.5.1 組み込み型**

- **1.5.2 リテラル**
    - リテラルとは、プログラム内に直接記述出来るデータ型の事を指す。

- **1.5.3 ポインタ**
    - 変数のアドレスを格納するための型をポインタ型という。
    - ```変数型* 変数名; ```は、変数型の値が格納されたアドレスが格納される。
    - &はアドレスを指し、*はアドレスを受け取った先の値を参照する演算子である。
    - ```cpp
    int i;
    int* i_addr = &i;
    *i_addr = 100;
    std::cout << "i = " << i << endl; 
    ```

- **1.5.4 const修飾子とポインタ**
    - constポインタは、間接参照演算子を使用しての値の変更を禁じる事が出来るポインタである。
    - ```const 型名* 変数名```もしくは```型名 const* 変数名```で宣言可能である。
    - ```
    const int a = 42;
    const int b = 0;
    int c = 10;

    const int* ptr = &a;    // OK   ptrに格納されているアドレスの変更は可能
    const int* ptr = &b;    // OK   ptrに格納されているアドレスの変更は可能
    const int* ptr = &c;    // OK   ptrに格納されているアドレスの変更は可能(const以外も可能)
    *ptr = 10;              // NG   アドレスの間接参照は不可
    ```
    - ポインタ自身をconstにする(=指し示すアドレスの変更が出来ない)事も可能である。
    - ```型名* const 変数名```となる。
    - ```
    int a = 42;
    int b = 0;

    int* const ptr = &a;    
    ptr = &b;               // NG   ptrに格納されているアドレスの変更は不可
    *ptr = 1000;            // OK   アドレスの間接参照は可能
    ``` 

- **1.5.5 ヌルポインタ**
    - ヌルポインタは、どの変数も指さない無効なアドレスを指す。
    - ```変数型* 変数名 = 0```もしくは```変数型* 変数名 = nullptr```で作成する。
    - ヌルポインタを間接参照するとプログラムがクラッシュする。

- **1.5.6 型変換**
    - キャスト演算子は、型変換を実施する事が可能である。
    - ```static_cast<変換後の型>(式)```

### 1.6 配列と文字列
- **1.6.1 配列**
    - 配列は、複数の変数を一定の並びで使用できるようにしたものを指す。
    - ```type array-name[length];```もしくは```type array-name[length] = {initial-values, ...};```もしくは```type array-name[] = {initial-values, ...};```で宣言可能である。

- **1.6.2 配列のサイズ**
    - 配列のサイズは、```sizeof(array) / sizeof(array[0])```で算出可能である。
- **1.6.3 文字列**
- **1.6.4 std::string**

### 1.7 繰り返し
- **1.7.1 while文**
- **1.7.2 for文**
- **1.7.3 do文**
- **1.5.6 型変換**


## 第二章 C++の基本的な言語機能Ⅱ

### 2.1 構造体・共用体・列挙体
- **2.1.1 構造体**
    - 構造体は複数の変数を一つの変数としてまとめて扱うための機能である。
    - ```
    // 作成時
    struct 構造体名{
        型 メンバ変数名1;
        型 メンバ変数名2;
        ...
    }

    //アクセス時
    構造体を格納した変数.メンバ変数名 //
    構造体のポインタ変数->メンバ変数  // 
    ```

- **2.1.2 共用体**
    - 複数のメンバー変数が同一アドレス上に存在する構造体を指す。
    - ```
    // 作成時
    union 共用体名{
        型 メンバ変数名1;
        型 メンバ変数名2;
        ...
    }
    
    ```

- **2.1.3 列挙体**
    - ```
    // 作成時
    enum class 列挙体名{
        列挙子1,
        列挙子2 = value,
        ...
    }

    // アクセス時
    列挙体名::列挙子名
    ```

### 2.2 クラス概要
    - **2.2.1 アクセス指定子**
        - 宣言したメンバ変数やメンバ関数のアクセスレベルを決定出来る。
        - デフォルトは、非公開設定となっている。
        - ```cpp
        class クラス名{
            // デフォルトのアクセス指定は非公開

            public:     //公開のアクセス指定子
                // 公開するメンバ変数やメンバ関数

            private:    // 非公開のアクセス指定子
                // 非公開なメンバ変数やメンバ関数
        }
        ```
    - **2.2.2 メンバ関数**
        - ```cpp
        class employee{
            int id;

        public:
            int get_id();
            void set_id(int new_id);
        }

        int product::get_id(){
            // メンバ関数の内側ではメンバ変数に直接アクセス出来る。
            return id;
        }

        void product::set_id(int new_id){
            // this.idやself.idといった記述は不必要である。
            id = new_id;
        }

        int main(){
            employee kevin;
            employee* kevin_ptr = &kevin;

            kevin.set_id(1);
            kevin_ptr->set_id(1);

        }
        ```

### 2.3 参照
    - **2.3.1 変数の別名**
        - 変数の別名を付ける機能を指す。
        - 構文は、```型名& 変数名 = 参照元の変数;```となる。
        - ```
        int main(){
            int value1 = 42;
            int value2 = 10;
            int& value_ref = value1;
            value_ref = 0;
            std::cout << value1 << std::endl;

            value_ref = value2;    // これは、value2の値がvalue1に代入されるのみである。   
        }
        ```
    - **2.3.3 const参照**
        - const参照は、値の代入が不可である。

### 2.4 型推論
    - **2.4.1 変数の型と初期値の型**
        - 初期値から変数の型を推定する機能を型推論という。
        - ```auto 変数名 = 初期値;```

    - **2.4.2 範囲for文の型推論**
        - 以下の例のように範囲for文を型推論する事も可能である。
        - ```
        #include <iostream>

        int main(){
            int array[] = {0, 1, 2, 3, 4, 5};

            for (auto i: array){
                std::cout << i;
            }
        }
        ```

    - **2.4.3 式の型を推論する**
        - 任意の式の型を調べる構文も存在する。
        - ```decltype(expression)```が該当する。
    
    - **2.4.4 配列の型推論**
        - 配列ではベクトルなどと混同されてしまうため、基本的に型推論する事が出来ない。

### 2.5 型の別名定義
    - **2.5.1 型に別の名前を与える**
        - 型名に他の名称を付ける事が可能である。
        - ```using 新しい型名 = 古い型名```

    - **2.5.2 ネストした型名**
        - クラスなどの中で型名を変更した場合、クラス外では以下のようにアクセス可能である。
        - ```クラス名::変更後の型名 ...```

    - **2.5.3 C言語との互換性**

### 2.6 コンソールからの入力
    - **2.6.1 std::cin**
        - std::cinでは文字列の入力を扱う事が可能である。
        - ```
        #include <iostream>

        int main()
        {
            int i;
            std::cout << "数値を入力してください。>";
            std::cin >> i;
            std::cout << "入力された数値は、" << i << "です。" << std::endl;
        }
        ```
    - **2.6.2 文字列の入力**
        - 文字列の入力を扱う場合は、最初の空白を除いた空白が出現した場合その直前までしか読み込まれない。
        - 一文全てを読み込まれるようにするためには、std::getline()関数を使用する。
        - ```
        #include <iostream>
        #include <string>

        int main(){
            std::string s;

            std::cout << "文字列を入力して下さい。>";

            std::getline(std::cin, s);

            std::cout << "入力された文字列は、" << s << "です。" << std::endl;
        }
        ```

### 2.7 関数オーバーロード
    - **2.7.1 引数の型が違うオーバーロード**
        - 関数オーバーロードとは、引数の型や型が異なるが同じ名前の関数を定義できる機能である。

    - **2.7.2 型が違うオーバーロード**
        -　```
        #include <iostream>

        void show_value(int a){
            std::cout << a << std::endl
        }

        int sum(int a, int b)
        {
            return a + b;
        }

        int sum(int a, int b, int c){
            return a + b + c;
        }
        ```

    - **2.7.2 デフォルト引数**

### 2.8 ラムダ式
    - **2.8.1 ラムダ式の基本**
        - 構文は、```[](parameters, ...) -> return-type {ラムダ関数}```である。
        - ここで、ラムダ式を格納する変数は常にautoを使用する必要がある。
        - ```
        int main(){
            auto show = [](int i) -> void{
                std::cout << "iの値は" << i << "です。" << std::endl;
            };

            show(42);
        }
        ```

    - **2.8.2 戻り値の型の省略**
        - ラムダ式では戻り値の型を省略する事が可能である。

    - **2.8.3 変数のコピーキャプチャ**
        - キャプチャは、ラムダ式の[]内に変数をいれる事で、変数のコピーを関数内で使用する事が出来る。
        - ```
        int main(){
            int a = 0;
            auto lambda = [a](){
                std::cout << a << std::endl;
            };

            lambda(); // Ans 0;
            
            a = 42;

            lambda(); // Ans 0; コピーしたのみなので、変更は影響しない。
        }
        ```
    
    - **2.8.4 変更可能なコピーキャプチャ**

## 第三章　クラス
### 3.1 constメンバー関数とmutable
    - **3.1.1  メンバー変数を変更する/しない関数**
        - constメンバー変数とは、インスタンスがconstとなっていても呼び出すことができるメンバー関数のことを指す。
        - ```
        class クラス名{
            public:
                // costメンバー関数の宣言
                戻り値 メンバー関数名(引数型 引数名, ....) const;
        };

        戻り値 メンバー関数名(引数型 引数名, ....) const{

        }
        ```
     - **3.1.2  cost/非consttメンバー関数間のオーバーロード**
        -  引数の型・数が異なる同名の関数を複数定義できる機能であるが、constメンバー関数かどうかでもオーバーロードすることが可能である。
    
    - **3.1.3 constメンバー関数でも書き込みを行いたい場合**
        - メンバー変数にmutable指定をすることで、constメンバー関数からでも書き換える操作を実施できるようになる。
        - ```c++
        class heavy_class
        {
            int m_value;

            mutable int m_cache;
            mutable bool m_cache_valid;

            public:
                int generate() const;
                void set(int value);
                int get() const;
        }

        int heavy_class::generate() const{
            std::cout << "とても重いデータ生成関数" << std::endl;
            return m_value;
        }

        int heavy_class::get() const{
            if (m_cache_valid) {return m_cache};

            m_cache = generate();
            m_cache_valid = true;

            return m_cache;
        }
        ```

### 3.2 コンストラクタとデストラクター
- **3.2.1  コンストラクターとは**
    - ```
    #include <iostream>
    #include <string>

    class person{
        std::string  m_name;
        int                 m_age;

        public:
            person();

            void set_name(std::string name);
            void set_age(int age);

            std::string  name() const;
            int                 age() const;
    };

    person::person(): m_age(-1){
        std::cout << "コンストラクタ呼び出し" << std::endl;
    }

    void person::set_name(std::string name){
        m_name
    }
    ```

    - **3.2.4 デストラクターとは**
        - インスタンスを開放する時に使用し、使用したメモリ領域を開放するために使用する。
        - ```cpp
        class クラス名{
            public:
                ~クラス名();
        }

        クラス名::~クラス名(){
            処理;
        }
        ```
        - コンストラクタで必要なメモリ領域を確保して、デストラクタで開放することをRALL(Resource Acquistion Is Initialization)という。

### 3.3 初期値を受け取るコンストラクター
- **3.3.1 コンストラクターは複数用意できる**
    - コンストラクターは複数用意することが可能であるが、引数を受け取らないデフォルトコンストラクターがなくなってしまう。

- **3.3.2 委譲コンストラクター**
    - コンストラクタが他のコンストラクターを呼ぶための仕組みを委譲コンストラクターと呼ぶ。
    - ```cpp
    class クラス名{
        public:クラス名(parameters...);

        ....
    };
    
    // 委譲元コンストラクター: 委譲先コンストラクタという書き順となる。
    クラス名::クラス名(parameters...): クラス名(引数){
        ...
    }
    ```

- **3.3.3 コピーコンストラクター**
    - クラスをコピーする際に使用されるコピーコンストラクターが存在する。
    - デフォルトのコピー操作では、ポインタのみのコピーとなるため、参照した状態となるためその操作を変更したい場合に使用する。
    - ```cpp
    class クラス名{
        public: 
            クラス名(const クラス名& 変数名);
    }
    
    ```

- **3.3.4 =を使用した初期化**
- **3.3.5 explicitを使用したコンストラクタ**


### 3.4 デフォルトの初期値

- **3.4.1 メンバー変数の初期値**
    - メンバー変数のデフォルト値を指定する構文をNSDMI(非静的メンバ変数の初期化子)という。
    - クラス以外にも構造体で使用可能である。
    - ```
    class クラス名{
        型名 変数名 = デフォルト値;
        型名 変数名 = {デフォルト値};
        型名 変数名(デフォルト値);
        型名 変数名 {デフォルト値};
    }
    ```

- **3.4.2 メンバー初期化リストと初期値**
    - コンストラクタとメンバー初期化リストが存在した場合は、コンストラクタの値が優先される。

### 3.5 継承の概要

- **3.5.1 継承とは**
    - 継承とは、似たような機能を持つ親クラス(基底クラス)から子クラスへとメンバ関数などの機能を派生させる機能を指す。
    - アクセス修飾子により、public/privateの選択が可能であるが、privateの場合は親クラスの機能に外部からアクセスすることが不可能になる。
    - ```
    class 子クラス名: アクセス修飾子 親クラス名{

    } 
    ``` 

- **3.5.2 仮想関数とオーバーライド**
    - 仮想関数とは、基底クラスにて子クラスの中で変更可能であると宣言されたメンバー関数のことを指す。

- **3.5.3 名前の隠蔽**

- **3.5.4  純粋仮想関数と抽象クラス**

### 3.6 オブジェクトポインター
- **3.6.1 アロー演算子**
    - ポインターを経由してメンバーにアクセスする際に、アロー演算子を使用する。
    - ```cpp
    #include <iostream>

    class A{
        public:
            void foo();
    };

    void A::foo(){
        std::cout << "A::foo()" << std::endl;
    }

    void call_foo(A* pa){
        pa->foo();
    }
    
    int main(){
        A a;
        call_foo(&a);
    }
    ```

- **3.6.2 thisポインター**
    - メンバー変数の中で、仮引数とメンバ属性がかぶっている場合はthis->を使用することができる。
    - ```cpp
        #include <iostream>

    class A{
        int foo;

        public:
            void foo();
    };

    void A::foo(){
        std::cout << "A::foo()" << std::endl;
    }

    void set_foo(int foo){
        this->foo = foo;
    }
    
    int main(){
        A a;
        set_foo();
    }
    ```

- **3.6.3 thisポインターは変更不可**
    - thisは予約された名前であるため、メンバー関数の中で宣言することはできない。

- **3.6.4 constメンバー関数とthisポインター**
    - thisポインタは、constメンバー関数のなかではconstポインターとなるため、値の変更ができない。

### 3.7 クラス・構造体・共用体の関係性
- **3.7.1 クラスと構造体の違い**
    - 構造体とクラスは基本的には同じものであるが、以下部分で違いがある。
        - デフォルトのアクセス方法において、クラスではprivateであるのに対して、構造体ではpublicである。
    - 主な使い分けとして、データをまとめる用途においては構造体を使用し、それ以外に動作を追加したい場合はクラスを使用する。

- **3.7.2 共用体とクラスの違い**
    - 

- **3.7.3 無名共用体**
    - 無名共用体とは、共用体のインスタンスは作成しないがいくつかの変数が同じメモリ上に配置されていることを確認するために使用する。

### 3.8 フレンド関数の概要

- **3.8.1 フレンド関数の宣言**
    - メンバー関数でないにも関わらず非公開メンバーにアクセスすることができる関数である。
    -  フレンド関数はメンバー関数ではないので、引数としてクラスのポインターや参照を一つ以上受け取るのが一般的である。
    - また、フレンド宣言は複数のクラスで宣言することは可能である。
    - ```cpp
    #include <iostream>

    class vector3d{
        float x;
        float y;
        float z;
        
        public:
            vector3d();
            explicit vector3d(float x, float y, float z);

            friend vector3d add(const vector3d& lhs, const vector3d& rhs);

            void dump() const;
    };
    ```

- **3.8.2 フレンド関数の注意点**
    - フレンド宣言はクラスの外側で行えないことは注意する。

### 3.9 staticクラスメンバー

- **3.9.1 staticクラスメンバーとは**
    - staticクラスメンバーとは、特定のインスタンス関数と結びつかないメンバー変数やメンバー関数のことを指す。
    - staticメンバー変数と特定のインスタンスひもづかないため、インスタンスがconstであっても変更可能である。
    - また、private・publicを使用できる。
    - ```cpp
    #include <iostream>

    class S
    {
        public:
            static int num;
    };

    int S::num = 123;
    ```

- **3.9.2 staticメンバー関数**
    - ```
    #include <iostream>

    class S
    {
        static int count;

        public:
            S();
            ~S();

            static void show_count();
    };

    int S::count = 0;

    S::S(){
        ++count;
    }

    S::~S(){
        --count;
    }

    void S::show_count(){
        std::cout << "S::count: " << count << std::endl;
    }
    ```
    

## 第4章 分割コンパイル・ビルド

### 4.1 識別子とC++のキーワード

- **4.1.1 識別子のルール**
    - 以下の識別子は予約している識別子の形式である。
        - アンダースコアが2つ連続した部分を含むもの。hoge__fuga
        - アンダースコアで始まり、大文字のアルファベットが少なくとも一つ続くもの。_Foo
        - アンダースコアで始まるもの。_0

- **4.1.2 C++で定義されているキーワード**

- **4.1.3 文脈依存キーワード**

- **4.1.4 代替表現**

- **4.1.5 暗黙的に定義される識別子**
    - 暗黙的に定義される識別子が以下の種類で存在する。
        - __FILE__
        - __LINE__
        - __func__
        - __cplusplus