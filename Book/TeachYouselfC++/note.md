# Teach Yourself C++



## 第一章 C++の基本的な言語機能


### 1.1 Hello, world
- **1.1.1 はじめてのC++プログラム**
    - ```
    #include <iostream>

    int main(){
        std::cout << "Hello, world" << std.endl;
    }
    
    ```

- **1.1.2 Hello, worldを読み解く**
    - #include命令はヘッダーファイルの読み込みのために使用される。
    - プログラムは値を生成する式(expression)と値を生成しない文(Statement)からなる。


### 1.2 変数と関数
- **1.2.1 変数とは**
    - 変数とは処理の結果を一時的に格納したり、その値を使って別の処理に使用する事が出来る。
    - 変数の宣言は、```変数の型 変数名;```で実施出来る。
    - 変数の宣言と初期化は、```変数の型 変数名 = リテラル;```もしくは```変数の型 変数名 = {リテラル};```もしくは```変数の型 変数名 {リテラル};```もしくは```変数の型 変数名(リテラル);```で実施できる。

- **1.2.2 const修飾子**
    - あとから代入する事が出来ない修飾子を作成するにはconst修飾子を使用する。
    - 宣言方法は、```const 変数型 変数名 = 値;```もしくは```変数型 const 変数名 = 値;```を用いる。
    - const変数は、宣言のみする事は出来ない。

- **1.2.3 関数**
    - 関数とは、複数の処理をまとめた塊で、一度関数を作成し、再利用可能なものである。
    - 宣言方法は、```戻り値型 関数名(引数型 引数名, ...){}```である。


### 1.3 演算子
- **1.3.1 算術演算子**

- **1.3.2 ビット演算子**
    - 2進数に対してのみ対応可能である。

- **1.3.3 sizeof演算子**
    - sizeof演算子は型名から型のサイズを取得する事が可能である。

- **1.3.4 複合代入演算子**

- **1.3.5 演算子の優先順位と結合規則**

### 1.4 条件分岐
- **1.4.1 if文と条件**
    - ```
    #include <iostream>

    int main(){
        int a = 9;
        if (a > 10){
            std::out << "a is more than 10." << std::endl;
        }else{
            std::out << "a is less than 10." << std::endl;
        }

        return 0;
    }
    ```

- **1.4.2 switch文**
    - ```
    #include <iostream>

    int main(){
        int a = 2;
        switch (a + 1){
            case 1:
                std::cout << "a + 1は1です。" << std::endl;
                break;
            case 2:
                std::cout << "a + 1は2です。" << std::endl;
                break;
            case 3:
                std::cout << "a + 1は3です。"  << std::endl;
                break;
            default:
                std::cout << "a + 1は" << a + 1 << "です。" << std::endl;
                break;
        }
        return 0;
    }
    ```
- 三項演算子
    - ```条件 ? 条件が正の時の値 : 条件が負の時の値```

### 1.5 組み込み型とポインタ

- **1.5.1 組み込み型**

- **1.5.2 リテラル**
    - リテラルとは、プログラム内に直接記述出来るデータ型の事を指す。

- **1.5.3 ポインタ**
    - 変数のアドレスを格納するための型をポインタ型という。
    - ```変数型* 変数名; ```は、変数型の値が格納されたアドレスが格納される。
    - &はアドレスを指し、*はアドレスを受け取った先の値を参照する演算子である。
    - ```cpp
    int i;
    int* i_addr = &i;
    *i_addr = 100;
    std::cout << "i = " << i << endl; 
    ```

- **1.5.4 const修飾子とポインタ**
    - constポインタは、間接参照演算子を使用しての値の変更を禁じる事が出来るポインタである。
    - ```const 型名* 変数名```もしくは```型名 const* 変数名```で宣言可能である。
    - ```
    const int a = 42;
    const int b = 0;
    int c = 10;

    const int* ptr = &a;    // OK   ptrに格納されているアドレスの変更は可能
    const int* ptr = &b;    // OK   ptrに格納されているアドレスの変更は可能
    const int* ptr = &c;    // OK   ptrに格納されているアドレスの変更は可能(const以外も可能)
    *ptr = 10;              // NG   アドレスの間接参照は不可
    ```
    - ポインタ自身をconstにする(=指し示すアドレスの変更が出来ない)事も可能である。
    - ```型名* const 変数名```となる。
    - ```
    int a = 42;
    int b = 0;

    int* const ptr = &a;    
    ptr = &b;               // NG   ptrに格納されているアドレスの変更は不可
    *ptr = 1000;            // OK   アドレスの間接参照は可能
    ``` 

- **1.5.5 ヌルポインタ**
    - ヌルポインタは、どの変数も指さない無効なアドレスを指す。
    - ```変数型* 変数名 = 0```もしくは```変数型* 変数名 = nullptr```で作成する。
    - ヌルポインタを間接参照するとプログラムがクラッシュする。

- **1.5.6 型変換**
    - キャスト演算子は、型変換を実施する事が可能である。
    - ```static_cast<変換後の型>(式)```

### 1.6 配列と文字列
- **1.6.1 配列**
    - 配列は、複数の変数を一定の並びで使用できるようにしたものを指す。
    - ```type array-name[length];```もしくは```type array-name[length] = {initial-values, ...};```もしくは```type array-name[] = {initial-values, ...};```で宣言可能である。

- **1.6.2 配列のサイズ**
    - 配列のサイズは、```sizeof(array) / sizeof(array[0])```で算出可能である。
- **1.6.3 文字列**
- **1.6.4 std::string**

### 1.7 繰り返し
- **1.7.1 while文**
- **1.7.2 for文**
- **1.7.3 do文**
- **1.5.6 型変換**


## 第二章 C++の基本的な言語機能Ⅱ

### 2.1 構造体・共用体・列挙体
- **2.1.1 構造体**
    - 構造体は複数の変数を一つの変数としてまとめて扱うための機能である。
    - ```
    // 作成時
    struct 構造体名{
        型 メンバ変数名1;
        型 メンバ変数名2;
        ...
    }

    //アクセス時
    構造体を格納した変数.メンバ変数名 //
    構造体のポインタ変数->メンバ変数  // 
    ```

- **2.1.2 共用体**
    - 複数のメンバー変数が同一アドレス上に存在する構造体を指す。
    - ```
    // 作成時
    union 共用体名{
        型 メンバ変数名1;
        型 メンバ変数名2;
        ...
    }
    
    ```

- **2.1.3 列挙体**
    - ```
    // 作成時
    enum class 列挙体名{
        列挙子1,
        列挙子2 = value,
        ...
    }

    // アクセス時
    列挙体名::列挙子名
    ```

### 2.2 クラス概要
    - **2.2.1 アクセス指定子**
        - 宣言したメンバ変数やメンバ関数のアクセスレベルを決定出来る。
        - デフォルトは、非公開設定となっている。
        - ```cpp
        class クラス名{
            // デフォルトのアクセス指定は非公開

            public:     //公開のアクセス指定子
                // 公開するメンバ変数やメンバ関数

            private:    // 非公開のアクセス指定子
                // 非公開なメンバ変数やメンバ関数
        }
        ```
    - **2.2.2 メンバ関数**
        - ```cpp
        class employee{
            int id;

        public:
            int get_id();
            void set_id(int new_id);
        }

        int product::get_id(){
            // メンバ関数の内側ではメンバ変数に直接アクセス出来る。
            return id;
        }

        void product::set_id(int new_id){
            // this.idやself.idといった記述は不必要である。
            id = new_id;
        }

        int main(){
            employee kevin;
            employee* kevin_ptr = &kevin;

            kevin.set_id(1);
            kevin_ptr->set_id(1);

        }
        ```

### 2.3 参照
    - **2.3.1 変数の別名**
        - 変数の別名を付ける機能を指す。
        - 構文は、```型名& 変数名 = 参照元の変数;```となる。
        - ```
        int main(){
            int value1 = 42;
            int value2 = 10;
            int& value_ref = value1;
            value_ref = 0;
            std::cout << value1 << std::endl;

            value_ref = value2;    // これは、value2の値がvalue1に代入されるのみである。   
        }
        ```
    - **2.3.3 const参照**
        - const参照は、値の代入が不可である。

### 2.4 型推論
    - **2.4.1 変数の型と初期値の型**
        - 初期値から変数の型を推定する機能を型推論という。
        - ```auto 変数名 = 初期値;```

    - **2.4.2 範囲for文の型推論**
        - 以下の例のように範囲for文を型推論する事も可能である。
        - ```
        #include <iostream>

        int main(){
            int array[] = {0, 1, 2, 3, 4, 5};

            for (auto i: array){
                std::cout << i;
            }
        }
        ```

    - **2.4.3 式の型を推論する**
        - 任意の式の型を調べる構文も存在する。
        - ```decltype(expression)```が該当する。
    
    - **2.4.4 配列の型推論**
        - 配列ではベクトルなどと混同されてしまうため、基本的に型推論する事が出来ない。

### 2.5 型の別名定義
    - **2.5.1 型に別の名前を与える**
        - 型名に他の名称を付ける事が可能である。
        - ```using 新しい型名 = 古い型名```

    - **2.5.2 ネストした型名**
        - クラスなどの中で型名を変更した場合、クラス外では以下のようにアクセス可能である。
        - ```クラス名::変更後の型名 ...```

    - **2.5.3 C言語との互換性**

### 2.6 コンソールからの入力
    - **2.6.1 std::cin**
        - std::cinでは文字列の入力を扱う事が可能である。
        - ```
        #include <iostream>

        int main()
        {
            int i;
            std::cout << "数値を入力してください。>";
            std::cin >> i;
            std::cout << "入力された数値は、" << i << "です。" << std::endl;
        }
        ```
    - **2.6.2 文字列の入力**
        - 文字列の入力を扱う場合は、最初の空白を除いた空白が出現した場合その直前までしか読み込まれない。
        - 一文全てを読み込まれるようにするためには、std::getline()関数を使用する。
        - ```
        #include <iostream>
        #include <string>

        int main(){
            std::string s;

            std::cout << "文字列を入力して下さい。>";

            std::getline(std::cin, s);

            std::cout << "入力された文字列は、" << s << "です。" << std::endl;
        }
        ```

### 2.7 関数オーバーロード
    - **2.7.1 引数の型が違うオーバーロード**
        - 関数オーバーロードとは、引数の型や型が異なるが同じ名前の関数を定義できる機能である。

    - **2.7.2 型が違うオーバーロード**
        -　```
        #include <iostream>

        void show_value(int a){
            std::cout << a << std::endl
        }

        int sum(int a, int b)
        {
            return a + b;
        }

        int sum(int a, int b, int c){
            return a + b + c;
        }
        ```

    - **2.7.2 デフォルト引数**

### 2.8 ラムダ式
    - **2.8.1 ラムダ式の基本**
        - 構文は、```[](parameters, ...) -> return-type {ラムダ関数}```である。
        - ここで、ラムダ式を格納する変数は常にautoを使用する必要がある。
        - ```
        int main(){
            auto show = [](int i) -> void{
                std::cout << "iの値は" << i << "です。" << std::endl;
            };

            show(42);
        }
        ```

    - **2.8.2 戻り値の型の省略**
        - ラムダ式では戻り値の型を省略する事が可能である。

    - **2.8.3 変数のコピーキャプチャ**
        - キャプチャは、ラムダ式の[]内に変数をいれる事で、変数のコピーを関数内で使用する事が出来る。
        - ```
        int main(){
            int a = 0;
            auto lambda = [a](){
                std::cout << a << std::endl;
            };

            lambda(); // Ans 0;
            
            a = 42;

            lambda(); // Ans 0; コピーしたのみなので、変更は影響しない。
        }
        ```
    
    - **2.8.4 変更可能なコピーキャプチャ**
