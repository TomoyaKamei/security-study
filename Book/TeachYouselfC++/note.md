# Teach Yourself C++



## 第一章 C++の基本的な言語機能


### 1.1 Hello, world
- **1.1.1 はじめてのC++プログラム**
    - ```
    #include <iostream>

    int main(){
        std::cout << "Hello, world" << std.endl;
    }
    
    ```

- **1.1.2 Hello, worldを読み解く**
    - #include命令はヘッダーファイルの読み込みのために使用される。
    - プログラムは値を生成する式(expression)と値を生成しない文(Statement)からなる。


### 1.2 変数と関数
- **1.2.1 変数とは**
    - 変数とは処理の結果を一時的に格納したり、その値を使って別の処理に使用する事が出来る。
    - 変数の宣言は、```変数の型 変数名;```で実施出来る。
    - 変数の宣言と初期化は、```変数の型 変数名 = リテラル;```もしくは```変数の型 変数名 = {リテラル};```もしくは```変数の型 変数名 {リテラル};```もしくは```変数の型 変数名(リテラル);```で実施できる。

- **1.2.2 const修飾子**
    - あとから代入する事が出来ない修飾子を作成するにはconst修飾子を使用する。
    - 宣言方法は、```const 変数型 変数名 = 値;```もしくは```変数型 const 変数名 = 値;```を用いる。
    - const変数は、宣言のみする事は出来ない。

- **1.2.3 関数**
    - 関数とは、複数の処理をまとめた塊で、一度関数を作成し、再利用可能なものである。
    - 宣言方法は、```戻り値型 関数名(引数型 引数名, ...){}```である。


### 1.3 演算子
- **1.3.1 算術演算子**

- **1.3.2 ビット演算子**
    - 2進数に対してのみ対応可能である。

- **1.3.3 sizeof演算子**
    - sizeof演算子は型名から型のサイズを取得する事が可能である。

- **1.3.4 複合代入演算子**

- **1.3.5 演算子の優先順位と結合規則**

### 1.4 条件分岐
- **1.4.1 if文と条件**
    - ```
    #include <iostream>

    int main(){
        int a = 9;
        if (a > 10){
            std::out << "a is more than 10." << std::endl;
        }else{
            std::out << "a is less than 10." << std::endl;
        }

        return 0;
    }
    ```

- **1.4.2 switch文**
    - ```
    #include <iostream>

    int main(){
        int a = 2;
        switch (a + 1){
            case 1:
                std::cout << "a + 1は1です。" << std::endl;
                break;
            case 2:
                std::cout << "a + 1は2です。" << std::endl;
                break;
            case 3:
                std::cout << "a + 1は3です。"  << std::endl;
                break;
            default:
                std::cout << "a + 1は" << a + 1 << "です。" << std::endl;
                break;
        }
        return 0;
    }
    ```
- 三項演算子
    - ```条件 ? 条件が正の時の値 : 条件が負の時の値```

### 1.5 組み込み型とポインタ

- **1.5.1 組み込み型**

- **1.5.2 リテラル**
    - リテラルとは、プログラム内に直接記述出来るデータ型の事を指す。

- **1.5.3 ポインタ**
    - 変数のアドレスを格納するための型をポインタ型という。
    - ```変数型* 変数名; ```は、変数型の値が格納されたアドレスが格納される。
    - &はアドレスを指し、*はアドレスを受け取った先の値を参照する演算子である。
    - ```cpp
    int i;
    int* i_addr = &i;
    *i_addr = 100;
    std::cout << "i = " << i << endl; 
    ```

- **1.5.4 const修飾子とポインタ**
    - constポインタは、間接参照演算子を使用しての値の変更を禁じる事が出来るポインタである。
    - ```const 型名* 変数名```もしくは```型名 const* 変数名```で宣言可能である。
    - ```
    const int a = 42;
    const int b = 0;
    int c = 10;

    const int* ptr = &a;    // OK   ptrに格納されているアドレスの変更は可能
    const int* ptr = &b;    // OK   ptrに格納されているアドレスの変更は可能
    const int* ptr = &c;    // OK   ptrに格納されているアドレスの変更は可能(const以外も可能)
    *ptr = 10;              // NG   アドレスの間接参照は不可
    ```
    - ポインタ自身をconstにする(=指し示すアドレスの変更が出来ない)事も可能である。
    - ```型名* const 変数名```となる。
    - ```
    int a = 42;
    int b = 0;

    int* const ptr = &a;    
    ptr = &b;               // NG   ptrに格納されているアドレスの変更は不可
    *ptr = 1000;            // OK   アドレスの間接参照は可能
    ``` 

- **1.5.5 ヌルポインタ**
    - ヌルポインタは、どの変数も指さない無効なアドレスを指す。
    - ```変数型* 変数名 = 0```もしくは```変数型* 変数名 = nullptr```で作成する。
    - ヌルポインタを間接参照するとプログラムがクラッシュする。

- **1.5.6 型変換**
    - キャスト演算子は、型変換を実施する事が可能である。
    - ```static_cast<変換後の型>(式)```

### 1.6 配列と文字列
- **1.6.1 配列**
    - 配列は、複数の変数を一定の並びで使用できるようにしたものを指す。
    - ```type array-name[length];```もしくは```type array-name[length] = {initial-values, ...};```もしくは```type array-name[] = {initial-values, ...};```で宣言可能である。

- **1.6.2 配列のサイズ**
    - 配列のサイズは、```sizeof(array) / sizeof(array[0])```で算出可能である。
- **1.6.3 文字列**
- **1.6.4 std::string**

### 1.7 繰り返し
- **1.7.1 while文**
- **1.7.2 for文**
- **1.7.3 do文**
- **1.5.6 型変換**


## 第二章 C++の基本的な言語機能Ⅱ